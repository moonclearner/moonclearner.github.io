<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Jq ajax]]></title>
    <url>%2Fjs%2Fjquery%2Fjq_ajax.html</url>
    <content type="text"><![CDATA[jquery Ajaxajax 请求question 1ajax请求成功后，success返回看不到data A：可能是因为服务器返回的数据不是json格式数据]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The notes of Reading Modern PHP book]]></title>
    <url>%2Fphp%2FmodernPHPNote.html</url>
    <content type="text"><![CDATA[The notes of Reading Modern PHP book前言author’s project: http://www.phptherightway.com, 目的是为了让php程序员轻易找到php社区中权威成员最新编写的高质量文档 目前开发流程 使用git来维护一个可以审查的代码历史 使用虚拟化工具varangt以及配置工具例如ansible、chef、puppet来搭建与生产服务器一样的开发环境 使用composer来管理php组件 php代码遵循PSR代码标准 phpUnit进行单元测试 php 引擎 Zend Engine (php4) PHP引擎是解析、解释和执行php代码的程序 Hack是建立在PHP之上的变成语言，引入了静态类型、新的数据结构、额外的接口，同时向后兼容所有的动态类型php代码 hiphop virtual machine(facebook)， HHVM，是php和hack的解释器，使用即时(just in time, JIT)编译器提高应用的性能，减少内存用量 新的特性命名空间 引入5.3 其作用是按照一种虚拟的层次结构组织php代码，避免类名以及变量冲突 接口1234567891011121314151617181920212223242526272829interface Documentable&#123; public function getId();&#125;class StreamDocument implements Documentable&#123; public function __construct($id) &#123; $this-&gt;id = $id; &#125; public function getId() &#123; return $this-&gt;id; &#125;&#125;class DocumentStore&#123; protected $data = []; public function addDocument(Documentable $document) &#123; $id = $document-&gt;getId(); $this-&gt;data[] = $id; &#125;&#125;$documentObject = new DocumentStore();$stream = new StreamDocument();$documentObject-&gt;addDocument($stream); 性状-traitphp5.4引入 性状是类的部分实现（即常量、属性和方法）, 可以混入一个或者多个现有的PHP类中 作用： 表明类可以做什么（像接口）；提供模板化实现（像类） 将两个没有共同父类的类具有类似行为，比如商店和猫，在地图上应该都有地标，如果将其都继承父类地理，这样就没有继承层次结构。使用接口的话，虽然可以保留自然的继承层次结构，但是我们需要实现相同的地理代码，不符合DRY原则，即Dont Repeat yourself 1234567891011121314trait MyGeo&#123; //性状实现 public function getGeo() &#123;&#125;&#125;class Cat&#123; use MyGeo; //类的实现&#125;$xiaobai = new Cat();$xiaobai-&gt;getGeo(); php解释器在编译的时候，会把性状复制粘贴到类的定义体里面，但是不会处理引入的不兼容问题，所以要确保类里面有性状使用的特定属性或者方法。 生成器php5.5 省内容1234567891011121314function getRow($file)&#123; $handle = fopen($file, &quot;rb&quot;); if($handle === false)&#123; throw new Exception(); &#125; while(feof($handle) === false)&#123; yield fgetcsv($handle); &#125; fclose($handle);&#125;foreach(getRow(&quot;test.csv&quot;) as $row)&#123; print_r($row);&#125; 匿名函数 和 闭包php5.3 php将匿名函数和闭包作为相同的概念，其实是伪装成函数的对象，都是Closure类的实例 12345$closure = function($name)&#123; return sprintf('Hello %s', $name)&#125;echo $closure("josh"); 闭包是指创建时封装周围状态的函数，即便闭包所在的环境不存在了，闭包中封装的状态依旧存在 我们之所以可以调用$closure变量，因为这个变量的值是一个闭包，而且闭包对象实现了一个_invoke()魔术方法，只要变量后面有()，php就会调用_invoke()方法 1array_map(function($number)&#123;return $number + 1;&#125;, [1,2,3]); 附加状态在php中需要手动调用bindTo()方法或者使用use将状态附加到php闭包中12345678function enclosePerson($name)&#123; return function($doCommand) use ($name)&#123; return sprintf('$s, $s', $name, $doCommand); &#125;&#125;$clay = enclosePerson('Clay');echo $clay("hello"); // Clay, hello enclosePerson()有个name参数，函数返回一个闭包对象，这个闭包封装了name参数，即便返回的对象跳出了enclosePerson()函数的作用域，它仍然会记住name的值，因为name仍在闭包里面。 可以用use将做个参数传入闭包里面 php闭包是对象，因此闭包实例都可以使用$this关键字来获取闭包内部的状态bindTo()方法，第二个参数为绑定闭包的那个对象所属的php类，因此绑定this，可以访问绑定闭包的对象中受保护和私有成员变量 123456789101112131415161718192021222324252627282930313233class App&#123; protected $routes = array(); protected $responseStatus = '200 ok'; protected $responseContentType = 'text/html'; protected $responseBody = 'Hello word'; public function addRoute($routePath, $routeCallback) &#123; $this-&gt;routes[$routePath] = $routeCallback-&gt;bindTo($this, __CLASS__); &#125; public function dispatch($currentPath) &#123; foreach ($this-&gt;routes as $routePath =&gt; $callback) &#123; if($routePath === $currentPath) &#123; $callback(); &#125; &#125; header('HTTP/1.1 '.$this-&gt;responseStatus); header('Content-type '.$this-&gt;responseContentType); header('Content-length '.mb_strlen($this-&gt;responseBody)); echo $this-&gt;responseBody; &#125;&#125;$app = new App();$app-&gt;addRoute('/users/josh', function()&#123; $this-&gt;responseContentType = 'application/json;charset=utf-8'; $this-&gt;responseBody = '&#123;"name":"josh"&#125;';&#125;)$app-&gt;dispatch('/users/josh'); Zend Opcache字节码缓存，php5.5 php是解释性语言，php解释器执行php脚本时，会解析php代码，将php代码编译成一系列Zend操作码，然后执行操作码。缓存预先编译好的字节码 1opcache.validate_timestamps = 1 //在生产环境中设为“0” 内置web服务器1php -S 0.0.0.0:4000 -c php.ini 良好实践PHP-FIG 实现框架的互操作性，通过接口，自动加载机制和标准的风格，让框架互相合作。 组件查找组件网站https://packagist.org 最好的组件 awesome php https://github.com/ziadoz/awesome-php 使用组件使用composer来管理php组件 安装：curl -sS https://getcomposer.org/installer | php]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP XML]]></title>
    <url>%2Fphp%2Fphp_xml.html</url>
    <content type="text"><![CDATA[php XMLDOMDocument遍历删除节点遍历删除节点的时候，会出现删除节点删除不干净，当你使用foreach来遍历的时候12foreach($nodes as $node)&#123;&#125; 是因为即当删除了第2个节点之后第3个节点会变成第2个节点，遍历的下个节点变成了第4个节点，跳过了对第3个节点的检查 当你使用foreach来遍历的时候123for($i=0; $i &lt; $nodes-&gt;length; $i++)&#123;&#125; 是因为即当删除了第2个节点之后第3个节点会变成第2个节点，遍历的下个节点变成了第4个节点，跳过了对第3个节点的检查并且节点的nodes-&gt;length会实时变化，导致最后的几个节点检查不到 solution方法1 额外使用一个指示器，来记录指向节点的位置，当删除节点的是指示器值不加1，这样就指向了下个节点123456789101112$dom = new DOMDocument();$dom-&gt;load($this-&gt;xmlfile);$nodes = $dom-&gt;getElementsByTagName('nodes');$index = 0;while($index &lt; $nodes-&gt;length) &#123; if (in_array($nodes-&gt;item($index)-&gt;getAttribute("id"), $ids)) &#123; $objectNode = $nodes-&gt;item($index); $objectNode-&gt;parentNode-&gt;removeChild($objectNode); &#125;else&#123; $index ++; &#125;&#125; 方法2先将所有节点遍历一遍，将要删除的节点存在一个数组里面，然后统一删除12345678foreach($nodes as $node)&#123; if (in_array($node-&gt;getAttribute("id"), $ids)) &#123; $delete[] = $node; &#125;&#125;foreach($delete as $val)&#123; $val-&gt;parentNode-&gt;removeChild($val);&#125; simplexml_load_file保存1234567function save($dom)&#123; if($dom-&gt;asXML("/test.xml"))&#123; return "success"; &#125;else&#123; return "fail"; &#125;&#125; 修改标签的值1234567891011121314151617181920212223242526$xml = @simplexml_load_file("/test.xml");//用xpath快速查找值$node = $xml-&gt;xpath("/node/config[@name='enable_tmp_files']")[0];/*&lt;node&gt;&lt;config name="test"&gt;&lt;/config&gt;&lt;/node&gt;*///读取标签间的值(string)$node-&gt;config;//读取标签的属性(string)$node-&gt;config["name"]//修改标签间的值dom_import_simplexml($node)-&gt;nodeValue = "true";/*&lt;node&gt; &lt;config enable="true"/&gt; &lt;config enable="true"/&gt; &lt;config enable="true"/&gt;&lt;/node&gt;*/foreach($node-&gt;config as $config)&#123; //修改标签的属性 $config["enable"] = "true";&#125; 删除某个节点内所有节点内容1dom_import_simplexml($node)-&gt;nodeValue = &quot;&quot;; 创建节点solution 1123$newnode = $node-&gt;addChild(&quot;newnode&quot;);$newnode = $node-&gt;addChild(&quot;newnode2&quot;, &quot;nodeValue&quot;);$newnode-&gt;addAttribute(&quot;newAttr&quot;, &quot;attrValue&quot;); solution 212$newnode = simplexml_load_string(&quot;&lt;newnode newAttr=&quot;attrValue&quot;&gt;nodeValue&lt;/newnode&gt;&quot;);dom_import_simplexml($node)-&gt;nodeValue = $newAttr; XMLReader简介此扩展需要 libxml PHP 扩展。这表示需要使用 –enable-libxml ，尽管这将隐式完成因为 libxml 是缺省开启的。 特点XMLReader是以Stream的形式读取数据，即纵然面对超大的xml文件用于读取大型xml，可以逐个节点进行读取操作，节约内存 用法1234567891011121314151617181920//读取bignode节点下的node节点,bignode后面的是smallnode节点不读取$z = new XMLReader();$z-&gt;open(&quot;/big.xml&quot;);$doc = new DOMDocument;// move to the first &lt;product /&gt; nodewhile ($z-&gt;read() &amp;&amp; $z-&gt;name !== &apos;product&apos;);// now that we&apos;re at the right depth, hop to the next &lt;product/&gt; until the end of the treewhile ($z-&gt;nodeType == XMLReader::ELEMENT &amp;&amp; $z-&gt;name === &apos;product&apos;)&#123; // either one should work //$node = new SimpleXMLElement($z-&gt;readOuterXML()); $node = simplexml_import_dom($doc-&gt;importNode($z-&gt;expand(), true)); // now you can use $node without going insane about parsing var_dump($node-&gt;element_1); // go to next &lt;product /&gt; $z-&gt;next(&apos;product&apos;);&#125; 读取单节点的方法使用simplexml的方法solution 112$xml = $z-&gt;readOuterXML();$xml = simplexml_load_string($xml); solution 21$node = new SimpleXMLElement($z-&gt;readOuterXML()); solution 312$doc = new DOMDocument;$node = simplexml_import_dom($doc-&gt;importNode($z-&gt;expand(), true)); 读取节点间的内容xml文件12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;rss xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; version=&quot;2.0&quot;&gt; &lt;channel&gt; &lt;title&gt;拍拍看科技&lt;/title&gt; &lt;link&gt;http://blog.limiwu.com/&lt;/link&gt; &lt;description&gt;关注科技产品和个人博客发展,注重用户体验和界面优化&lt;/description&gt; &lt;item&gt; &lt;title&gt;新购买了一个域名：losehub.com&lt;/title&gt; &lt;link&gt;http://blog.limiwu.com/537.html&lt;/link&gt; &lt;description&gt;最近新购买了一个域名losehub.com。准备来做一个PHP项目， 具体的还在谋划中。不知道什么时候能开始制作呢。&lt;/description&gt; &lt;pubDate&gt;Tue, 27 Dec 2016 14:47:25 +0800&lt;/pubDate&gt; &lt;/item&gt; ... &lt;/channel&gt;&lt;/rss&gt; 123456789101112131415161718192021222324252627while ($reader-&gt;read())&#123; if($reader-&gt;nodeType == XMLReader::ELEMENT)&#123; $nodeName = $reader-&gt;name; &#125; //注意XMLReader::TEXT 是识别不了CDATA，如果需要读取CDATA 可以改成$reader-&gt;nodeType == XMLReader::CDATA if($reader-&gt;nodeType == XMLReader::TEXT &amp;&amp; !empty($nodeName))&#123; switch($nodeName)&#123; case &apos;title&apos;: if ($reader -&gt; depth == &apos;4&apos;)&#123; $title = $reader-&gt;value; &#125; break; case &apos;link&apos;: if ($reader -&gt; depth == &apos;4&apos;)&#123; $link = $reader-&gt;value; &#125; break; case &apos;description&apos;: $description = $reader-&gt;value; break; case &apos;pubDate&apos;: $pubDate = $reader-&gt;value; break; &#125; &#125; &#125; $reader-&gt;close(); XMLReader 常量12345678910111213141516171819202122XMLReader::NONE = 0 ;XMLReader::ELEMENT = 1 ;XMLReader::ATTRIBUTE = 2 ;XMLReader::TEXT = 3 ;XMLReader::CDATA = 4 ;XMLReader::ENTITY_REF = 5 ;XMLReader::ENTITY = 6 ;XMLReader::PI = 7 ;XMLReader::COMMENT = 8 ;XMLReader::DOC = 9 ;XMLReader::DOC_TYPE = 10 ;XMLReader::DOC_FRAGMENT = 11 ;XMLReader::NOTATION = 12 ;XMLReader::WHITESPACE = 13 ;XMLReader::SIGNIFICANT_WHITESPACE = 14 ;XMLReader::END_ELEMENT = 15 ;XMLReader::END_ENTITY = 16 ;XMLReader::XML_DECLARATION = 17 ;XMLReader::LOADDTD = 1 ;XMLReader::DEFAULTATTRS = 2 ;XMLReader::VALIDATE = 3 ;XMLReader::SUBST_ENTITIES = 4 ; XMLReader 方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859a、XMLReader::XML作用：载入 xml 字符串用法：XMLReader::xml(string source [, string encoding [, int options]] )参数：source，xml string；encoding，document encoding or NULL返回：如果成功则返回 TRUE，失败则返回 FALSE。b、XMLReader::open作用：载入xml文件用法：XMLReader::open(string url [, string encoding [, int options]] )参数：url，连接到xml的链接；encoding，document encoding or NULL返回：如果成功则返回 TRUE，失败则返回 FALSE。c、XMLReader::read作用：读取 xml，使解析器前进到下一个标记用法：XMLReader::read()，在 while 循环中遍历整个文档参数：NULL返回：如果成功则返回 TRUE，失败则返回 FALSE。d、XMLReader::getAttribute作用：获取属性用法：XMLReader::getAttribute(string name)参数：name，属性名称返回：如果成功则返回 属性值，失败则返回 FALSE。e、XMLReader::isValid作用：检验xml是否合法用法：XMLReader::isValid()参数：无返回：如果成功则返回 true，失败则返回 FALSE。f、XMLReader::moveToAttribute作用：移动焦点到所指的属性上用法：XMLReader::moveToAttribute(string name)参数：name，属性名称返回：如果成功则返回 true，失败则返回 FALSE。g、XMLReader::moveToFirstAttribute作用：移动焦点到第一个属性上用法：XMLReader::moveToFirstAttribute()参数：无返回：如果成功则返回 true，失败则返回 FALSE。h、XMLReader::moveToNextAttribute作用：移动焦点到下一个属性上用法：XMLReader::moveToNextAttribute()参数：无返回：如果成功则返回 true，失败则返回 FALSE。i、XMLReader::moveToElement作用：移动焦点到父节点当前属性上用法：XMLReader::moveToElement()参数：无返回：如果成功则返回 true，失败则返回 FALSE。j、XMLReader::close作用：关闭xml输入用法：XMLReader::close()参数：无返回：如果成功则返回 true，失败则返回 FALSE。 XMLReader属性1234567891011121314151617181920212223242526272829a、XMLReader-&gt;attributeCount ;作用：属性数量b、XMLReader-&gt;baseURI ;作用：节点的urlc、XMLReader-&gt;depth ;作用：节点树的层数d、XMLReader-&gt;hasAttributes ;作用：检测是否有属性e、XMLReader-&gt;hasValue ;作用：是否有值f、XMLReader-&gt;isEmptyElement ;作用：是否是空标签g、XMLReader-&gt;localName ;作用：标签内部明h、XMLReader-&gt;name ;作用：标签名i、XMLReader-&gt;nodeType ;作用：节点类型j、XMLReader-&gt;value ;作用：节点文本内容 ————————————————版权声明：本文为CSDN博主「安南子.com」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_45578749/article/details/100131799]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python library description]]></title>
    <url>%2Fpython%2FlibDescription.html</url>
    <content type="text"><![CDATA[1、环境管理：管理 Python 版本和环境的工具。p – 非常简单的交互式 python 版本管理工具。pyenv – 简单的 Python 版本管理工具。Vex – 可以在虚拟环境中执行命令。virtualenv – 创建独立 Python 环境的工具。virtualenvwrapper– virtualenv 的一组扩展。 2、包管理：管理包和依赖的工具。pip – Python 包和依赖关系管理工具。pip-tools – 保证 Python 包依赖关系更新的一组工具。conda – 跨平台，Python 二进制包管理工具。Curdling – 管理 Python 包的命令行工具。wheel – Python 分发的新标准，意在取代 eggs。 3、包仓库：本地 PyPI 仓库服务和代理。warehouse – 下一代 PyPI。Warehouse bandersnatch – PyPA 提供的 PyPI 镜像工具。devpi – PyPI 服务和打包/测试/分发工具。localshop – 本地 PyPI 服务（自定义包并且自动对 PyPI 镜像）。 4、分发：打包为可执行文件以便分发。PyInstaller – 将 Python 程序转换成独立的执行文件（跨平台）。dh-virtualenv – 构建并将 virtualenv 虚拟环境作为一个 Debian 包来发布。Nuitka – 将脚本、模块、包编译成可执行文件或扩展模块。py2app – 将 Python 脚本变为独立软件包（Mac OS X）。py2exe – 将 Python 脚本变为独立软件包（Windows）。pynsist – 一个用来创建 Windows 安装程序的工具，可以在安装程序中打包 Python本身。 5、构建工具：将源码编译成软件。buildout – 一个构建系统，从多个组件来创建，组装和部署应用。BitBake – 针对嵌入式 Linux 的类似 make 的构建工具。fabricate – 对任何语言自动找到依赖关系的构建工具。PlatformIO – 多平台命令行构建工具。PyBuilder – 纯 Python 实现的持续化构建工具。SCons – 软件构建工具。 6、交互式解析器：交互式 Python 解析器。IPython – 功能丰富的工具，非常有效的使用交互式 Python。bpython– 界面丰富的 Python 解析器。ptpython – 高级交互式Python解析器， 构建于python-prompt-toolkit 之上。 7、文件：文件管理和 MIME（多用途的网际邮件扩充协议）类型检测。imghdr – （Python 标准库）检测图片类型。mimetypes – （Python 标准库）将文件名映射为 MIME 类型。path.py – 对 os.path 进行封装的模块。pathlib – （Python3.4+ 标准库）跨平台的、面向对象的路径操作库。python-magic– 文件类型检测的第三方库 libmagic 的 Python 接口。Unipath– 用面向对象的方式操作文件和目录watchdog – 管理文件系统事件的 API 和 shell 工具 8、日期和时间：操作日期和时间的类库。arrow– 更好的 Python 日期时间操作类库。Chronyk – Python 3 的类库，用于解析手写格式的时间和日期。dateutil – Python datetime 模块的扩展。delorean– 解决 Python 中有关日期处理的棘手问题的库。moment – 一个用来处理时间和日期的Python库。灵感来自于Moment.js。PyTime – 一个简单易用的Python模块，用于通过字符串来操作日期/时间。pytz – 现代以及历史版本的世界时区定义。将时区数据库引入Python。when.py – 提供用户友好的函数来帮助用户进行常用的日期和时间操作。 9、文本处理：用于解析和操作文本的库。9.1通用chardet – 字符编码检测器，兼容 Python2 和 Python3。difflib – (Python 标准库)帮助我们进行差异化比较。ftfy – 让Unicode文本更完整更连贯。fuzzywuzzy – 模糊字符串匹配。Levenshtein – 快速计算编辑距离以及字符串的相似度。pangu.py – 在中日韩语字符和数字字母之间添加空格。pyfiglet -figlet 的 Python实现。shortuuid – 一个生成器库，用以生成简洁的，明白的，URL 安全的 UUID。unidecode – Unicode 文本的 ASCII 转换形式 。uniout – 打印可读的字符，而不是转义的字符串。xpinyin – 一个用于把汉字转换为拼音的库。 9.2 Slug化awesome-slugify – 一个 Python slug 化库，可以保持 Unicode。python-slugify – Python slug 化库，可以把 unicode 转化为 ASCII。unicode-slugify – 一个 slug 工具，可以生成 unicode slugs ,需要依赖 Django 。 9.3 解析器phonenumbers – 解析，格式化，储存，验证电话号码。PLY – lex 和 yacc 解析工具的 Python 实现。Pygments – 通用语法高亮工具。pyparsing – 生成通用解析器的框架。python-nameparser – 把一个人名分解为几个独立的部分。python-user-agents – 浏览器 user agent 解析器。sqlparse – 一个无验证的 SQL 解析器。 10、特殊文本格式处理：一些用来解析和操作特殊文本格式的库。10.1 通用tablib – 一个用来处理中表格数据的模块。10.2 OfficeMarmir – 把输入的Python 数据结构转换为电子表单。openpyxl – 一个用来读写 Excel 2010 xlsx/xlsm/xltx/xltm 文件的库。python-docx – 读取，查询以及修改 Microsoft Word 2007/2008 docx 文件。unoconv – 在 LibreOffice/OpenOffice 支持的任意文件格式之间进行转换。XlsxWriter – 一个用于创建 Excel .xlsx 文件的 Python 模块。xlwings – 一个使得在 Excel 中方便调用 Python 的库（反之亦然），基于 BSD 协议。xlwt / xlrd – 读写 Excel 文件的数据和格式信息。relatorio – 模板化OpenDocument 文件。10.3 PDFPDFMiner – 一个用于从PDF文档中抽取信息的工具。PyPDF2 – 一个可以分割，合并和转换 PDF 页面的库。ReportLab – 快速创建富文本 PDF 文档。10.4 MarkdownMistune – 快速并且功能齐全的纯 Python 实现的 Markdown 解析器。Python-Markdown – John Gruber’s Markdown 的 Python 版实现。10.5 YAMLPyYAML – Python 版本的 YAML 解析器。10.6 CSVcsvkit – 用于转换和操作 CSV 的工具。10.7 Archiveunp – 一个用来方便解包归档文件的命令行工具。 11、自然语言处理：用来处理人类语言的库。NLTK – 一个先进的平台，用以构建处理人类语言数据的 Python 程序。jieba – 中文分词工具。langid.py – 独立的语言识别系统。Pattern – Python 网络信息挖掘模块。SnowNLP – 一个用来处理中文文本的库。TextBlob – 为进行普通自然语言处理任务提供一致的 API。TextGrocery – 一简单高效的短文本分类工具，基于 LibLinear 和 Jieba。 12、文档：用以生成项目文档的库。Sphinx – Python 文档生成器。awesome-sphinxdocMkDocs – 对 Markdown 友好的文档生成器。pdoc – 一个可以替换Epydoc 的库，可以自动生成 Python 库的 API 文档。Pycco – 文学编程（literate-programming）风格的文档生成器。 13、配置：用来保存和解析配置的库。config – logging 模块作者写的分级配置模块。ConfigObj – INI 文件解析器，带验证功能。ConfigParser – (Python 标准库) INI 文件解析器。profig – 通过多种格式进行配置，具有数值转换功能。python-decouple – 将设置和代码完全隔离。 14、命令行工具：用于创建命令行程序的库。14.1 命令行程序开发cement – Python 的命令行程序框架。click – 一个通过组合的方式来创建精美命令行界面的包。cliff – 一个用于创建命令行程序的框架，可以创建具有多层命令的命令行程序。clint – Python 命令行程序工具。colorama – 跨平台彩色终端文本。docopt – Python 风格的命令行参数解析器。Gooey – 一条命令，将命令行程序变成一个 GUI 程序。python-prompt-toolkit – 一个用于构建强大的交互式命令行程序的库。14.2 生产力工具aws-cli – Amazon Web Services 的通用命令行界面。bashplotlib – 在终端中进行基本绘图。caniusepython3 – 判断是哪个项目妨碍你你移植到 Python 3。cookiecutter – 从 cookiecutters（项目模板）创建项目的一个命令行工具。doitlive – 一个用来在终端中进行现场演示的工具。howdoi – 通过命令行获取即时的编程问题解答。httpie – 一个命令行HTTP 客户端，cURL 的替代品，易用性更好。PathPicker – 从bash输出中选出文件。percol – 向UNIX shell 传统管道概念中加入交互式选择功能。SAWS – 一个加强版的 AWS 命令行。thefuck – 修正你之前的命令行指令。mycli – 一个 MySQL 命令行客户端，具有自动补全和语法高亮功能。pgcli – Postgres 命令行工具，具有自动补全和语法高亮功能。 15、下载器：用来进行下载的库。s3cmd – 一个用来管理Amazon S3 和 CloudFront 的命令行工具。s4cmd – 超级 S3 命令行工具，性能更加强劲。you-get – 一个 YouTube/Youku/Niconico 视频下载器，使用 Python3 编写。youtube-dl – 一个小巧的命令行程序，用来下载 YouTube 视频。 16、图像处理：用来操作图像的库。pillow – Pillow 是一个更加易用版的 PIL。hmap – 图像直方图映射。imgSeek – 一个使用视觉相似性搜索一组图片集合的项目。nude.py – 裸体检测。pyBarcode – 不借助 PIL 库在 Python 程序中生成条形码。pygram – 类似 Instagram 的图像滤镜。python-qrcode – 一个纯 Python 实现的二维码生成器。Quads – 基于四叉树的计算机艺术。scikit-image – 一个用于（科学）图像处理的 Python 库。thumbor – 一个小型图像服务，具有剪裁，尺寸重设和翻转功能。wand – MagickWand的Python 绑定。MagickWand 是 ImageMagick的 C API 。 17、OCR：光学字符识别库。pyocr – Tesseract 和 Cuneiform 的一个封装(wrapper)。pytesseract – Google Tesseract OCR 的另一个封装(wrapper)。python-tesseract – Google Tesseract OCR 的一个包装类。 18、音频：用来操作音频的库。audiolazy -Python 的数字信号处理包。audioread – 交叉库 (GStreamer + Core Audio + MAD + FFmpeg) 音频解码。beets – 一个音乐库管理工具及 MusicBrainz 标签添加工具dejavu – 音频指纹提取和识别django-elastic-transcoder – Django + Amazon Elastic Transcoder。eyeD3 – 一个用来操作音频文件的工具，具体来讲就是包含 ID3 元信息的 MP3 文件。id3reader – 一个用来读取 MP3 元数据的 Python 模块。m3u8 – 一个用来解析 m3u8 文件的模块。mutagen – 一个用来处理音频元数据的 Python 模块。pydub – 通过简单、简洁的高层接口来操作音频文件。pyechonest – Echo Nest API 的 Python 客户端talkbox – 一个用来处理演讲/信号的 Python 库TimeSide – 开源 web 音频处理框架。tinytag – 一个用来读取MP3, OGG, FLAC 以及 Wave 文件音乐元数据的库。mingus – 一个高级音乐理论和曲谱包，支持 MIDI 文件和回放功能。 19、Video：用来操作视频和GIF的库。moviepy – 一个用来进行基于脚本的视频编辑模块，适用于多种格式，包括动图 GIFs。scikit-video – SciPy 视频处理常用程序。 20、地理位置：地理编码地址以及用来处理经纬度的库。GeoDjango – 世界级地理图形 web 框架。GeoIP – MaxMind GeoIP Legacy 数据库的 Python API。geojson – GeoJSON 的 Python 绑定及工具。geopy – Python 地址编码工具箱。pygeoip – 纯 Python GeoIP API。django-countries – 一个 Django 应用程序，提供用于表格的国家选择功能，国旗图标静态文件以及模型中的国家字段。 21、HTTP：使用HTTP的库。requests – 人性化的HTTP请求库。grequests – requests 库 + gevent ，用于异步 HTTP 请求.httplib2 – 全面的 HTTP 客户端库。treq – 类似 requests 的Python API 构建于 Twisted HTTP 客户端之上。urllib3 – 一个具有线程安全连接池，支持文件 post，清晰友好的 HTTP 库。 22、数据库：Python实现的数据库。pickleDB – 一个简单，轻量级键值储存数据库。PipelineDB – 流式 SQL 数据库。TinyDB – 一个微型的，面向文档型数据库。ZODB – 一个 Python 原生对象数据库。一个键值和对象图数据库。 23、数据库驱动：用来连接和操作数据库的库。MySQL – awesome-mysql系列mysql-python – Python 的 MySQL 数据库连接器。mysqlclient – mysql-python 分支，支持 Python 3。oursql – 一个更好的 MySQL 连接器，支持原生预编译指令和 BLOBs.PyMySQL – 纯 Python MySQL 驱动，兼容 mysql-python。 24、PostgreSQLpsycopg2 – Python 中最流行的 PostgreSQL 适配器。queries – psycopg2 库的封装，用来和 PostgreSQL 进行交互。txpostgres – 基于 Twisted 的异步 PostgreSQL 驱动。其他关系型数据库apsw – 另一个 Python SQLite封装。dataset – 在数据库中存储Python字典 – 可以协同SQLite，MySQL，和 PostgreSQL工作。pymssql– 一个简单的Microsoft SQL Server数据库接口。NoSQL 数据库cassandra-python-driver – Cassandra 的 Python 驱动。HappyBase – 一个为 Apache HBase 设计的，对开发者友好的库。Plyvel – 一个快速且功能丰富的 LevelDB 的 Python 接口。py2neo – Neo4j restful 接口的Python 封装客户端。pycassa – Cassandra 的 Python Thrift 驱动。PyMongo – MongoDB 的官方 Python 客户端。redis-py – Redis 的 Python 客户端。telephus – 基于 Twisted 的 Cassandra 客户端。txRedis – 基于 Twisted 的 Redis 客户端。ORM：实现对象关系映射或数据映射技术的库。关系型数据库awesome-sqlalchemy系列Django Models – Django 的一部分。SQLAlchemy – Python SQL 工具以及对象关系映射工具。Peewee – 一个小巧，富有表达力的 ORM。PonyORM – 提供面向生成器的 SQL 接口的 ORM。python-sql – 编写 Python 风格的 SQL 查询。NoSQL 数据库django-mongodb-engine – Django MongoDB 后端。PynamoDB – Amazon DynamoDB 的一个 Python 风格接口。flywheel – Amazon DynamoDB 的对象映射工具。MongoEngine – 一个Python 对象文档映射工具，用于 MongoDB。hot-redis – 为 Redis 提供 Python 丰富的数据类型。redisco – 一个 Python 库，提供可以持续存在在 Redis 中的简单模型和容器。 25、其他butterdb – Google Drive 电子表格的 Python ORM。 26、Web 框架全栈 web 框架。Django – Python 界最流行的 web 框架。awesome-django系列Flask – 一个 Python 微型框架。awesome-flask系列Pyramid – 一个小巧，快速，接地气的开源Python web 框架。awesome-pyramid系列Bottle – 一个快速小巧，轻量级的 WSGI 微型 web 框架。CherryPy – 一个极简的 Python web 框架，服从 HTTP/1.1 协议且具有WSGI 线程池。TurboGears – 一个可以扩展为全栈解决方案的微型框架。web.py – 一个 Python 的 web 框架，既简单，又强大。web2py – 一个全栈 web 框架和平台，专注于简单易用。Tornado – 一个web 框架和异步网络库。 27、权限：允许或拒绝用户访问数据或功能的库。Carteblanche – Module to align code with thoughts of users and designers. Also magically handles navigation and permissions.django-guardian – Django 1.2+ 实现了单个对象权限。django-rules – 一个小巧但是强大的应用，提供对象级别的权限管理，且不需要使用数据库。 28、CMS:内容管理系统django-cms – 一个开源的，企业级 CMS，基于 Django。djedi-cms – 一个轻量级但却非常强大的 Django CMS ，考虑到了插件，内联编辑以及性能。FeinCMS – 基于 Django 构建的最先进的内容管理系统之一。Kotti – 一个高级的，Python 范的 web 应用框架，基于 Pyramid 构建。Mezzanine – 一个强大的，持续的，灵活的内容管理平台。Opps – 一个为杂志，报纸网站以及大流量门户网站设计的 CMS 平台，基于 Django。Plone – 一个构建于开源应用服务器 Zope 之上的 CMS。Quokka – 灵活，可扩展的小型 CMS，基于 Flask 和 MongoDB。Wagtail – 一个 Django 内容管理系统。Widgy – 最新的 CMS 框架，基于 Django。 29、电子商务:用于电子商务以及支付的框架和库。django-oscar – 一个用于 Django 的开源的电子商务框架。django-shop – 一个基于 Django 的店铺系统。Cartridge – 一个基于 Mezzanine 构建的购物车应用。shoop – 一个基于 Django 的开源电子商务平台。alipay – 非官方的 Python 支付宝 API。merchant – 一个可以接收来自多种支付平台支付的 Django 应用。money – 货币类库with optional CLDR-backed locale-aware formatting and an extensible currency exchange solution.python-currencies – 显示货币格式以及它的数值。 30、RESTful API:用来开发RESTful APIs的库30.1 Djangodjango-rest-framework – 一个强大灵活的工具，用来构建 web API。django-tastypie – 为Django 应用开发API。django-formapi – 为 Django 的表单验证，创建 JSON APIs 。30.2 Flaskflask-api – 为 flask 开发的，可浏览 Web APIs 。flask-restful – 为 flask 快速创建REST APIs 。flask-restless – 为 SQLAlchemy 定义的数据库模型创建 RESTful APIs 。flask-api-utils – 为 Flask 处理 API 表示和验证。eve – REST API 框架，由 Flask, MongoDB 等驱动。30.3 Pyramidcornice – 一个Pyramid 的 REST 框架 。30.4 与框架无关的falcon – 一个用来建立云 API 和 web app 后端的噶性能框架。sandman – 为现存的数据库驱动系统自动创建 REST APIs 。restless – 框架无关的 REST 框架 ，基于从 Tastypie 学到的知识。ripozo – 快速创建 REST/HATEOAS/Hypermedia APIs。 31、验证:实现验证方案的库。31.1 OAuthAuthomatic – 简单但是强大的框架，身份验证/授权客户端。django-allauth – Django 的验证应用。django-oauth-toolkit – 为 Django 用户准备的 OAuth2。django-oauth2-provider – 为 Django 应用提供 OAuth2 接入。Flask-OAuthlib – OAuth 1.0/a, 2.0 客户端实现，供 Flask 使用。OAuthLib – 一个 OAuth 请求-签名逻辑通用、 完整的实现。python-oauth2 – 一个完全测试的抽象接口。用来创建 OAuth 客户端和服务端。python-social-auth – 一个设置简单的社会化验证方式。rauth – OAuth 1.0/a, 2.0, 和 Ofly 的 Python 库。sanction – 一个超级简单的OAuth2 客户端实现。31.2 其他jose – JavaScript 对象签名和加密草案的实现。PyJWT – JSON Web 令牌草案 01。python-jws – JSON Web 签名草案 02 的实现。python-jwt – 一个用来生成和验证 JSON Web 令牌的模块。 32、模板引擎：模板生成和词法解析的库和工具。Jinja2 – 一个现代的，对设计师友好的模板引擎。Chameleon – 一个 HTML/XML 模板引擎。 模仿了 ZPT（Zope Page Templates）, 进行了速度上的优化。Genshi – Python 模板工具，用以生成 web 感知的结果。Mako – Python 平台的超高速轻量级模板。 33、Queue：处理事件以及任务队列的库。celery – 一个异步任务队列/作业队列，基于分布式消息传递。huey – 小型多线程任务队列。mrq – Mr. Queue -一个 Python 的分布式 worker 任务队列， 使用 Redis 和 gevent。rq – 简单的 Python 作业队列。simpleq – 一个简单的，可无限扩张的，基于亚马逊 SQS 的队列。 34、搜索：对数据进行索引和执行搜索查询的库和软件。django-haystack – Django 模块化搜索。elasticsearch-py – Elasticsearch 的官方底层 Python 客户端。elasticsearch-dsl-py -Elasticsearch 的官方高级 Python 客户端。solrpy – solr的 Python 客户端。Whoosh – 一个快速的纯 Python 搜索引擎库。 35、动态消息：用来创建用户活动的库。django-activity-stream – 从你的站点行为中生成通用活动信息流。Stream-Framework – 使用 Cassandra 和 Redis 创建动态消息和通知系统。 36、资源管理：管理、压缩、缩小网站资源的工具。django-compressor – 将链接和内联的 JavaScript 或 CSS 压缩到一个单独的缓存文件中。django-storages – 一个针对 Django 的自定义存储后端的工具集合。fanstatic – 打包、优化，并且把静态文件依赖作为 Python 的包来提供。File Conveyor – 一个后台驻留的程序，用来发现和同步文件到 CDNs, S3 和 FTP。Flask-Assets – 帮你将 web 资源整合到你的 Flask app 中。jinja-assets-compressor – 一个 Jinja 扩展，用来编译和压缩你的资源。webassets – 为你的静态资源打包、优化和管理生成独一无二的缓存 URL。 37、缓存：缓存数据的库。Beaker – 一个缓存和会话库，可以用在 web 应用和独立 Python脚本和应用上。django-cache-machine – Django 模型的自动缓存和失效。django-cacheops– 具有自动颗粒化事件驱动失效功能的 ORM。django-viewlet – 渲染模板，同时具有额外的缓存控制功能。dogpile.cache – dogpile.cache 是 Beaker 的下一代替代品，由同一作者开发。HermesCache – Python 缓存库，具有基于标签的失效和 dogpile effect 保护功能。johnny-cache – django应用缓存框架。pylibmc – libmemcached 接口的 Python 封装。 38、电子邮件：用来发送和解析电子邮件的库。django-celery-ses – 带有 AWS SES 和 Celery 的 Django email 后端。envelopes – 供人类使用的电子邮件库。flanker – 一个 email 地址和 Mime 解析库。imbox – Python IMAP 库inbox.py – Python SMTP 服务器。inbox – 一个开源电子邮件工具箱。lamson – Python 风格的 SMTP 应用服务器。mailjet – Mailjet API 实现，用来提供批量发送邮件，统计等功能。marrow.mailer – 高性能可扩展邮件分发框架。modoboa – 一个邮件托管和管理平台，具有现代的、简约的 Web UI。pyzmail – 创建，发送和解析电子邮件。Talon – Mailgun 库，用来抽取信息和签名。 39、国际化：用来进行国际化的库。Babel – 一个Python 的国际化库。Korean – 一个韩语词态库。 40、URL处理：解析URLs的库。furl – 一个让处理 URL 更简单小型 Python 库。purl – 一个简单的，不可变的URL类，具有简洁的 API 来进行询问和处理。pyshorteners – 一个纯 Python URL 缩短库。shorturl– 生成短小 URL 和类似 bit.ly 短链的Python 实现。webargs – 一个解析 HTTP 请求参数的库，内置对流行 web 框架的支持，包括 Flask, Django, Bottle, Tornado和 Pyramid。 41、HTML处理：处理 HTML和XML的库。BeautifulSoup – 以 Python 风格的方式来对 HTML 或 XML 进行迭代，搜索和修改。bleach – 一个基于白名单的 HTML 清理和文本链接库。cssutils – 一个 Python 的 CSS 库。html5lib – 一个兼容标准的 HTML 文档和片段解析及序列化库。lxml – 一个非常快速，简单易用，功能齐全的库，用来处理 HTML 和 XML。MarkupSafe – 为Python 实现 XML/HTML/XHTML 标记安全字符串。pyquery – 一个解析 HTML 的库，类似 jQuery。untangle – 将XML文档转换为Python对象，使其可以方便的访问。xhtml2pdf – HTML/CSS 转 PDF 工具。xmltodict – 像处理 JSON 一样处理 XML。 42、网络站点爬取：爬取网络站点的库。Scrapy – 一个快速高级的屏幕爬取及网页采集框架。cola – 一个分布式爬虫框架。Demiurge – 基于PyQuery 的爬虫微型框架。feedparser – 通用 feed 解析器。Grab – 站点爬取框架。MechanicalSoup – 用于自动和网络站点交互的 Python 库。portia – Scrapy 可视化爬取。pyspider – 一个强大的爬虫系统。RoboBrowser – 一个简单的，Python 风格的库，用来浏览网站，而不需要一个独立安装的浏览器。 43、网页内容提取：用于进行网页内容提取的库。Haul – 一个可以扩展的图像爬取工具。html2text – 将 HTML 转换为 Markdown 格式文本lassie – 人性化的网页内容检索库。micawber -一个小型网页内容提取库，用来从 URLs 提取富内容。newspaper – 使用 Python 进行新闻提取，文章提取以及内容策展。opengraph – 一个用来解析开放内容协议(Open Graph Protocol)的 Python模块。python-goose – HTML内容/文章提取器。python-readability– arc90 公司 readability 工具的 Python 高速端口sanitize – 为杂乱的数据世界带来调理性。sumy – 一个为文本文件和 HTML 页面进行自动摘要的模块。textract – 从任何格式的文档中提取文本，Word，PowerPoint，PDFs 等等。 44、表单：进行表单操作的库。Deform – Python HTML 表单生成库，受到了 formish 表单生成库的启发。django-bootstrap3– 集成了 Bootstrap 3 的 Django。django-crispy-forms – 一个 Django 应用，他可以让你以一种非常优雅且 DRY（Don’t repeat yourself） 的方式来创建美观的表单。django-remote-forms– 一个平台独立的 Django 表单序列化工具。WTForms – 一个灵活的表单验证和呈现库。WTForms-JSON– 一个 WTForms 扩展，用来处理 JSON 数据。 45、数据验证：数据验证库，多用于表单验证。Cerberus – A mappings-validator with a variety of rules, normalization-features and simple customization that uses a pythonic schema-definition.colander – 一个用于对从 XML, JSON，HTML 表单获取的数据或其他同样简单的序列化数据进行验证和反序列化的系统。kmatch – 一种用于匹配/验证/筛选 Python 字典的语言。schema -一个用于对 Python 数据结构进行验证的库。Schematics – 数据结构验证。valideer – 轻量级可扩展的数据验证和适配库。voluptuous – 一个 Python 数据验证库。主要是为了验证传入 Python的 JSON，YAML 等数据。 46、反垃圾技术：帮助你和电子垃圾进行战斗的库。django-simple-captcha – 一个简单、高度可定制的Django 应用，可以为任何Django表单添加验证码。django-simple-spam-blocker– 一个用于Django的简单的电子垃圾屏蔽工具。 47、标记：用来进行标记的库。django-taggit – 简单的 Django 标记工具。 48、管理面板：管理界面库。Ajenti – 一个你的服务器值得拥有的管理面板。django-suit – Django 管理界面的一个替代品 (仅对于非商业用途是免费的)。django-xadmin – Django admin 的一个替代品，具有很多不错的功能。flask-admin – 一个用于 Flask 的简单可扩展的管理界面框架。flower – 一个对 Celery 集群进行实时监控和提供 web 管理界面的工具。Grappelli – Django 管理界面的一个漂亮的皮肤。Wooey – 一个 Django 应用，可以为 Python 脚本创建 web 用户界面。 49、静态站点生成器：静态站点生成器是一个软件，它把文本和模板作为输入，然后输出HTML文件。Pelican – 使用 Markdown 或 ReST 来处理内容， Jinja 2 来制作主题。支持 DVCS, Disqus.。AGPL 许可。Cactus – 为设计师设计的静态站点生成器。Hyde – 基于 Jinja2 的静态站点生成器。Nikola – 一个静态网站和博客生成器。Tinkerer – Tinkerer 是一个博客引擎/静态站点生成器，由Sphinx驱动。Lektor – 一个简单易用的静态 CMS 和博客引擎。 50、进程：操作系统进程启动及通信库。envoy – 比 Python subprocess 模块更人性化。sarge – 另一 种 subprocess 模块的封装。sh – 一个完备的 subprocess 替代库。 51、并发和并行：用以进行并发和并行操作的库。multiprocessing – (Python 标准库) 基于进程的“线程”接口。threading – (Python 标准库)更高层的线程接口。eventlet – 支持 WSGI 的异步框架。gevent – 一个基于协程的 Python 网络库，使用greenlet。Tomorrow -用于产生异步代码的神奇的装饰器语法实现。 52、网络：用于网络编程的库。asyncio – (Python 标准库) 异步 I/O, 事件循环, 协程以及任务。Twisted – 一个事件驱动的网络引擎。pulsar – 事件驱动的并发框架。diesel – 基于Greenlet 的事件 I/O 框架。pyzmq – 一个 ZeroMQ 消息库的 Python 封装。txZMQ – 基于 Twisted 的 ZeroMQ 消息库的 Python 封装。 53、WebSocket：帮助使用WebSocket的库。AutobahnPython – 给 Python 、使用的 WebSocket &amp; WAMP 基于 Twisted 和 asyncio。Crossbar – 开源统一应用路由(Websocket &amp; WAMP for Python on Autobahn).django-socketio – 给 Django 用的 WebSockets。WebSocket-for-Python – 为Python2/3 以及 PyPy 编写的 WebSocket 客户端和服务器库。 54、WSGI 服务器：兼容 WSGI 的 web 服务器gunicorn – Pre-forked, 部分是由 C 语言编写的。uwsgi – uwsgi 项目的目的是开发一组全栈工具，用来建立托管服务， 由 C 语言编写。bjoern – 异步，非常快速，由 C 语言编写。fapws3 – 异步 (仅对于网络端)，由 C 语言编写。meinheld – 异步，部分是由 C 语言编写的。netius – 异步，非常快速。paste – 多线程，稳定，久经考验。rocket – 多线程。waitress – 多线程, 是它驱动着 Pyramid 框架。Werkzeug – 一个 WSGI 工具库，驱动着 Flask ，而且可以很方便大嵌入到你的项目中去。 55、RPC 服务器：兼容 RPC 的服务器。SimpleJSONRPCServer – 这个库是 JSON-RPC 规范的一个实现。SimpleXMLRPCServer – (Python 标准库) 简单的 XML-RPC 服务器实现，单线程。zeroRPC – zerorpc 是一个灵活的 RPC 实现，基于 ZeroMQ 和 MessagePack。 56、密码学：cryptography – 这个软件包意在提供密码学基本内容和方法提供给 Python 开发者。hashids – 在 Python 中实现 hashids 。Paramiko – SSHv2 协议的 Python (2.6+, 3.3+) ，提供客户端和服务端的功能。Passlib – 安全密码存储／哈希库，PyCrypto – Python 密码学工具箱。PyNacl – 网络和密码学(NaCl) 库的 Python 绑定。 57、图形用户界面：用来创建图形用户界面程序的库。curses – 内建的 ncurses 封装，用来创建终端图形用户界面。enaml – 使用类似 QML 的Declaratic语法来创建美观的用户界面。kivy – 一个用来创建自然用户交互（NUI）应用程序的库，可以运行在 Windows, Linux, Mac OS X, Android 以及 iOS平台上。pyglet – 一个Python 的跨平台窗口及多媒体库。PyQt – 跨平台用户界面框架 Qt 的 Python 绑定 ，支持Qt v4 和 Qt v5。PySide – P跨平台用户界面框架 Qt 的 Python 绑定 ，支持Qt v4。Tkinter – Tkinter 是 Python GUI 的一个事实标准库。Toga – 一个 Python 原生的, 操作系统原生的 GUI 工具包。urwid – 一个用来创建终端 GUI 应用的库，支持组件，事件和丰富的色彩等。PyGObject – GLib/GObject/GIO/GTK+ (GTK+3) 的 Python 绑定Flexx – Flexx 是一个纯 Python 语言编写的用来创建 GUI 程序的工具集，它使用 web 技术进行界面的展示。 58、游戏开发：超赞的游戏开发库。Cocos2d – cocos2d 是一个用来开发 2D 游戏， 示例和其他图形/交互应用的框架。基于 pyglet。Panda3D – 由迪士尼开发的 3D 游戏引擎，并由卡内基梅陇娱乐技术中心负责维护。使用C++编写, 针对 Python 进行了完全的封装。Pygame – Pygame 是一组 Python 模块，用来编写游戏。PyOgre – Ogre 3D 渲染引擎的 Python 绑定，可以用来开发游戏和仿真程序等任何 3D 应用。PyOpenGL – OpenGL 的 Python 绑定及其相关 APIs。PySDL2 – SDL2 库的封装，基于 ctypes。RenPy – 一个视觉小说（visual novel）引擎。 59、日志：用来生成和操作日志的库。logging – (Python 标准库) 为 Python 提供日志功能。logbook – Logging 库的替代品。Eliot – 为复杂的和分布式系统创建日志。Raven – Sentry的 Python 客户端。Sentry – 实时记录和收集日志的服务器。 60、Testing：进行代码库测试和生成测试数据的库。60.1测试框架unittest – (Python 标准库) 单元测试框架。nose – nose 扩展了 unittest 的功能。contexts – 一个 Python 3.3+ 的 BDD 框架。受到C# –Machine.Specifications的启发。hypothesis – Hypothesis 是一个基于先进的 Quickcheck 风格特性的测试库。mamba – Python 的终极测试工具， 拥护BDD。PyAutoGUI – PyAutoGUI 是一个人性化的跨平台 GUI 自动测试模块。pyshould– Should 风格的断言，基于 PyHamcrest。pytest– 一个成熟的全功能 Python 测试工具。green– 干净，多彩的测试工具。pyvows– BDD 风格的测试工具，受Vows.js的启发。Robot Framework – 一个通用的自动化测试框架。60.2 Web 测试Selenium – Selenium WebDriver 的 Python 绑定。locust – 使用 Python 编写的，可扩展的用户加载测试工具。sixpack – 一个和语言无关的 A/B 测试框架。splinter – 开源的 web 应用测试工具。60.3 Mock测试mock – (Python 标准库) 一个用于伪造测试的库。doublex – Python 的一个功能强大的 doubles 测试框架。freezegun – 通过伪造日期模块来生成不同的时间。httmock – 针对 Python 2.6+ 和 3.2+ 生成 伪造请求的库。httpretty – Python 的 HTTP 请求 mock 工具。responses – 伪造 Python 中的 requests 库的一个通用库。VCR.py – 在你的测试中记录和重放 HTTP 交互。60.4 对象工厂factoryboy – 一个 Python 用的测试固件 (test fixtures) 替代库。mixer – 另外一个测试固件 (test fixtures) 替代库，支持 Django, Flask, SQLAlchemy, Peewee 等。modelmommy – 为 Django 测试创建随机固件 61、代码覆盖率coverage – 代码覆盖率测量。 62、伪数据faker – 一个 Python 库，用来生成伪数据。fake2db – 伪数据库生成器。radar – 生成随机的日期/时间。 63、错误处理FuckIt.py – FuckIt.py 使用最先进的技术来保证你的 Python 代码无论对错都能继续运行。 64、代码分析和Lint工具：进行代码分析，解析和操作代码库的库和工具。64.1 代码分析code2flow – 把你的 Python 和 JavaScript 代码转换为流程图。pycallgraph -这个库可以把你的Python 应用的流程(调用图)进行可视化。pysonar2 – Python 类型推断和检索工具。64.2 Lint工具Flake8 – 模块化源码检查工具: pep8, pyflakes 以及 co。Pylint – 一个完全可定制的源码分析器。pylama – Python 和 JavaScript 的代码审查工具。 65、Debugging Tools：用来进行代码调试的库。65.1 调试器ipdb – IPython 启用的 pdb。pudb – 全屏，基于控制台的 Python 调试器。pyringe – 可以在 Python 进程中附加和注入代码的调试器。wdb – 一个奇异的 web 调试器，通过 WebSockets 工作。winpdb – 一个具有图形用户界面的 Python 调试器，可以进行远程调试，基于 rpdb2。django-debug-toolbar – 为 Django 显示各种调试信息。django-devserver – 一个 Django 运行服务器的替代品。flask-debugtoolbar – django-debug-toolbar 的 flask 版。65.2 性能分析器lineprofiler – 逐行性能分析。memoryprofiler – 监控 Python 代码的内存使用。profiling – 一个交互式 Python 性能分析工具。65.3 其他pyelftools – 解析和分析 ELF 文件以及 DWARF 调试信息。python-statsd – statsd 服务器的 Python 客户端。 66、Science and Data Analysis：用来进行科学计算和数据分析的库。astropy – 一个天文学 Python 库。bcbio-nextgen – 这个工具箱为全自动高通量测序分析提供符合最佳实践的处理流程。bccb – 生物分析相关代码集合Biopython – Biopython 是一组可以免费使用的用来进行生物计算的工具。blaze – NumPy 和 Pandas 的大数据接口。cclib – 一个用来解析和解释计算化学软件包输出结果的库。NetworkX – 一个为复杂网络设计的高性能软件。Neupy – 执行和测试各种不同的人工神经网络算法。Numba – Python JIT (just in time) 编译器，针对科学用的 Python ，由Cython 和 NumPy 的开发者开发。NumPy – 使用 Python 进行科学计算的基础包。Open Babel – 一个化学工具箱，用来描述多种化学数据。Open Mining – 使用 Python 挖掘商业情报 (BI) (Pandas web 接口)。orange – 通过可视化编程或 Python 脚本进行数据挖掘，数据可视化，分析和机器学习。Pandas – 提供高性能，易用的数据结构和数据分析工具。PyDy – PyDy 是 Python Dynamics 的缩写，用来为动力学运动建模工作流程提供帮助， 基于 NumPy, SciPy, IPython 和 matplotlib。PyMC – 马尔科夫链蒙特卡洛采样工具。RDKit – 化学信息学和机器学习软件。SciPy – 由一些基于 Python ，用于数学，科学和工程的开源软件构成的生态系统。statsmodels – 统计建模和计量经济学。SymPy – 一个用于符号数学的 Python 库。zipline – 一个 Python 算法交易库。 67、数据可视化：进行数据可视化的库。 参见: awesome-javascript。matplotlib – 一个 Python 2D 绘图库。bokeh – 用 Python 进行交互式 web 绘图。ggplot – ggplot2 给 R 提供的 API 的 Python 版本。plotly – 协同 Python 和 matplotlib 工作的 web 绘图库。pygal – 一个 Python SVG 图表创建工具。pygraphviz – Graphviz 的 Python 接口。PyQtGraph – 交互式实时2D/3D/图像绘制及科学/工程学组件。SnakeViz – 一个基于浏览器的 Python’s cProfile 模块输出结果查看工具。vincent – 把 Python 转换为 Vega 语法的转换工具。VisPy – 基于 OpenGL 的高性能科学可视化工具。 68、计算机视觉：计算机视觉库。OpenCV – 开源计算机视觉库。SimpleCV – 一个用来创建计算机视觉应用的开源框架。 69、机器学习：机器学习库。 参见: awesome-machine-learning.Crab – 灵活、快速的推荐引擎。gensim – 人性化的话题建模库。hebel – GPU 加速的深度学习库。NuPIC – 智能计算 Numenta 平台。pattern – Python 网络挖掘模块。PyBrain – 另一个 Python 机器学习库。Pylearn2 – 一个基于 Theano 的机器学习库。python-recsys – 一个用来实现推荐系统的 Python 库。scikit-learn – 基于 SciPy 构建的机器学习 Python 模块。pydeep – Python 深度学习库。vowpalporpoise – 轻量级 Vowpal Wabbit 的 Python 封装。skflow – 一个 TensorFlow 的简化接口(模仿 scikit-learn)。 70、MapReduce：MapReduce 框架和库。dpark – Spark 的 Python 克隆版，一个类似 MapReduce 的框架。dumbo – 这个 Python 模块可以让人轻松的编写和运行 Hadoop 程序。luigi – 这个模块帮你构建批处理作业的复杂流水线。mrjob – 在 Hadoop 或 Amazon Web Services 上运行 MapReduce 任务。PySpark – Spark 的 Python API 。streamparse – 运行针对事实数据流的 Python 代码。集成了Apache Storm。 71、函数式编程：使用 Python 进行函数式编程。CyToolz – Toolz 的 Cython 实现 : 高性能函数式工具。fn.py – 在 Python 中进行函数式编程 : 实现了一些享受函数式编程缺失的功能。funcy – 炫酷又实用的函数式工具。Toolz – 一组用于迭代器，函数和字典的函数式编程工具。 72、第三方 API：用来访问第三方 API的库。 参见： List of Python API Wrappers and Libraries。apache-libcloud – 一个为各种云设计的 Python 库。boto – Amazon Web Services 的 Python 接口。django-wordpress – WordPress models and views for Django.facebook-sdk – Facebook 平台的 Python SDK.facepy – Facepy 让和 Facebook’s Graph API 的交互变得更容易。gmail – Gmail 的 Python 接口。google-api-python-client – Python 用的 Google APIs 客户端库。gspread – Google 电子表格的 Python API.twython – Twitter API 的封装。 73、DevOps 工具：用于 DevOps 的软件和库。Ansible – 一个非常简单的 IT 自动化平台。SaltStack – 基础设施自动化和管理系统。OpenStack – 用于构建私有和公有云的开源软件。Docker Compose – 快速，分离的开发环境，使用 Docker。Fabric – 一个简单的，Python 风格的工具，用来进行远程执行和部署。cuisine – 为 Fabric 提供一系列高级函数。Fabtools – 一个用来编写超赞的 Fabric 文件的工具。gitapi – Git 的纯 Python API。hgapi – Mercurial 的纯 Python API。honcho – Foreman的 Python 克隆版，用来管理基于Procfile的应用。pexpect – Controlling interactive programs in a pseudo-terminal like 在一个伪终端中控制交互程序，就像 GNU expect 一样。psutil – 一个跨平台进程和系统工具模块。supervisor – UNIX 的进程控制系统。 74、任务调度：任务调度库。APScheduler – 轻巧但强大的进程内任务调度，使你可以调度函数。django-schedule – 一个 Django 排程应用。doit – 一个任务执行和构建工具。gunnery – 分布式系统使用的多用途任务执行工具 ，具有 web 交互界面。Joblib – 一组为 Python 提供轻量级作业流水线的工具。Plan – 如有神助地编写 crontab 文件。schedule – 人性化的 Python 任务调度库。Spiff – 使用纯 Python 实现的强大的工作流引擎。TaskFlow – 一个可以让你方便执行任务的 Python 库，一致并且可靠。 75、外来函数接口：使用外来函数接口的库。cffi – 用来调用 C 代码的外来函数接口。ctypes – (Python 标准库) 用来调用 C 代码的外来函数接口。PyCUDA – Nvidia CUDA API 的封装。SWIG – 简化的封装和接口生成器。 76、高性能：让 Python 更快的库。Cython – 优化的 Python 静态编译器。使用类型混合使 Python 编译成 C 或 C++ 模块来获得性能的极大提升。PeachPy – 嵌入 Python 的 x86-64 汇编器。可以被用作 Python 内联的汇编器或者是独立的汇编器，用于 Windows, Linux, OS X, Native Client 或者 Go 。PyPy – 使用 Python 实现的 Python。解释器使用黑魔法加快 Python 运行速度且不需要加入额外的类型信息。Pyston – 使用 LLVM 和现代 JIT 技术构建的 Python 实现，目标是为了获得很好的性能。Stackless Python – 一个强化版的 Python。 77、微软的 Windows平台：在 Windows 平台上进行 Python 编程。Anaconda(强烈推荐)：使用科学软件包免费发布Python。支持Linux，Windows和Mac。Enthought Canopy：免费和商业版本包括核心科学包。支持Linux，Windows和Mac。Python（x，y）：一个免费的发行版，包括基于 Qt 和Spyder IDE的科学包 。支持Windows和Ubuntu；仅限Py2。WinPython：另一个免费发行版，包括科学软件包和Spyder IDE。仅限Windows，但更积极地维护并支持最新的Python 3版本。Pyzo：基于Anaconda和IEP交互式开发环境的免费发行版。支持Linux，Windows和Mac。Pythonlibs：非官方的 Windows 平台 Python 扩展二进制包。PythonNet： Python 与 .NET 公共语言运行库 (CLR)的集成。PyWin32：针对 Windows 的Python 扩展。 78、网络可视化和SDN：用来进行网络可视化和SDN(软件定义网络)的工具和库。Mininet – 一款流行的网络模拟器以及用 Python 编写的 API。POX – 一个针对基于 Python 的软件定义网络应用（例如 OpenFlow SDN 控制器）的开源开发平台。Pyretic – 火热的 SDN 编程语言中的一员，为网络交换机和模拟器提供强大的抽象能力。SDX Platform – 基于 SDN 的 IXP 实现，影响了 Mininet, POX 和 Pyretic。 79、硬件：用来对硬件进行编程的库。ino -操作Arduino的命令行工具。Pyro – Python 机器人编程库。PyUserInput – 跨平台的，控制鼠标和键盘的模块。scapy – 一个非常棒的操作数据包的库。wifi – 一个 Python 库和命令行工具用来在 Linux 平台上操作WiFi。Pingo – Pingo 为类似Raspberry Pi，pcDuino， Intel Galileo等设备提供统一的API用以编程。 80、兼容性：帮助从 Python 2 向 Python 3迁移的库。Python-Future – 这就是 Python 2 和 Python 3 之间丢失的那个兼容性层。Python-Modernize – 使 Python 代码更加现代化以便最终迁移到 Python 3。Six – Python 2 和 3 的兼容性工具。 81、杂项：不属于上面任何一个类别，但是非常有用的库。blinker – 一个快速的 Python 进程内信号/事件分发系统。itsdangerous – 一系列辅助工具用来将可信的数据传入不可信的环境。pluginbase – 一个简单但是非常灵活的 Python 插件系统。Pychievements – 一个用来创建和追踪成就的 Python 框架。Tryton – 一个通用商务框架。 82、算法和设计模式：Python 实现的算法和设计模式。algorithms -一个 Python 算法模块python-patterns – Python 设计模式的集合。sortedcontainers – 快速，纯 Python 实现的SortedList，SortedDict 和 SortedSet 类型。 83、编辑器插件：编辑器和 IDE 的插件。83.1 Emacs：Elpy – Emacs Python 开发环境。83.2 Sublime Text：SublimeJEDI – 一个 Sublime Text 插件，用来使用超赞的自动补全库 Jedi。Anaconda – Anaconda 把你的 Sublime Text 3 变成一个功能齐全的 Python IDE。83.3 Vim：YouCompleteMe – 引入基于 Jedi 的 Python 自动补全引擎。Jedi-vim – 绑定 Vim 和 Jedi 自动补全库对 Python 进行自动补全。Python-mode – 将 Vim 变成 Python IDE 的一款多合一插件。83.4 Visual Studio：PTVS – Visual Studio 的 Python 工具 84、集成开发环境：流行的 Python 集成开发环境。PyCharm – 商业化的 Python IDE ，由 JetBrains 开发。也有免费的社区版提供。LiClipse – 基于 Eclipse 的免费多语言 IDE 。使用 PyDev 来支持 Python 。Spyder – 开源 Python IDE。 85、服务：在线工具和简化开发的 API 。85.1 持续集成：参见: awesome-CIandCD.Travis CI – 一个流行的工具，为你的开源和私人项目提供持续集成服务。(仅支持 GitHub)CircleCI – 一个持续集成工具，可以非常快速的进行并行测试。 (仅支持 GitHub)Vexor CI – 一个为私人 app 提供持续集成的工具，支持按分钟付费。Wercker – 基于 Docker 平台，用来构建和部署微服务。85.2 代码质量：Codacy – 自动化代码审查，更加快速的发布高质量代码。对于开源项目是免费的。QuantifiedCode – 一个数据驱动、自动、持续的代码审查工具。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql learning note]]></title>
    <url>%2Fdatabases%2Fmysql%2Fnotes.html</url>
    <content type="text"><![CDATA[mysql learning note性能查询原因： 没有命中索引 没有分页处理 最大数据量MySQL没有限制单位最大记录数，其取决于os以及文件系统对单文件最大的限制 最大并发数由maxconnections和maxuserconnections决定 maxconnections是指MySQL实例的最大连接数，上限值是16384，maxuserconnections是指每个数据库用户的最大连接数 MySQL会为每个连接提供缓冲区，意味着消耗更多的内存。如果连接数设置太高硬件吃不消，太低又不能充分利用硬件。一般要求两者比值超过10%，计算方法如下：1max_used_connections / max_connections * 100% = 3/100 *100% ≈ 3% 查看最大连接数与响应最大连接数：12show variables like &apos;%max_connections%&apos;;show variables like &apos;%max_user_connections%&apos;; 在配置文件my.cnf中修改最大连接数1[mysqld]max_connections = 100max_used_connections = 20 查询耗时0.5秒建议将单次查询耗时控制在0.5秒以内，0.5秒是个经验值，源于用户体验的3秒原则 。如果用户的操作3秒内没有响应，将会厌烦甚至退出。响应时间=客户端UI渲染耗时+网络请求耗时+应用程序处理耗时+查询数据库耗时，0.5秒就是留给数据库1/6的处理时间 实施原则相比NoSQL数据库，MySQL容量小并发低、SQL约束太多。应用程序扩容比数据库要容易得多，所以实施原则是 数据库少干活，应用程序多干活 充分利用但不滥用索引，须知索引也消耗磁盘和CPU。 不推荐使用数据库函数格式化数据，交给应用程序处理。 不推荐使用外键约束，用应用程序保证数据准确性。 写多读少的场景，不推荐使用唯一索引，用应用程序保证唯一性。 适当冗余字段，尝试创建中间表，用应用程序计算中间结果，用空间换时间。 不允许执行极度耗时的事务，配合应用程序拆分成更小的事务。 预估重要数据表（比如订单表）的负载和数据增长态势，提前优化。 表设计数据类型数据类型的选择原则：更简单或者占用空间更小 如果长度能够满足，整型尽量使用tinyint、smallint、medium_int而非int 如果字符串长度确定，采用char类型 如果varchar能够满足，不采用text类型 精度要求较高的使用decimal类型，也可以使用BIGINT，比如精确两位小数就乘以100后保存 尽量采用timestamp而非datetime 类型 占据字节 描述 datetime 8个字节 ‘1000-01-01 00:00:00.000000’ to ‘9999-12-31 23:59:59.999999 timestamp 4字节 ‘1970-01-01 00:00:01.000000’ to ‘2038-01-19 03:14:07.999999’ avoid null valueMySQL中字段为NULL时依然占用空间，会使索引、索引统计更加复杂。从NULL值更新到非NULL无法做到原地更新，容易发生索引分裂影响性能。尽可能将NULL值用有意义的值代替，也能避免SQL语句里面包含 is not null的判断 text type Optimization由于text字段储存大量数据，表容量会很早涨上去，影响其他字段的查询性能。建议抽取出来放在子表里，用业务主键关联 引索optimizationindex 分类 普通索引：最基本的索引。 组合索引：多个字段上建立的索引，能够加速复合查询条件的检索。 唯一索引：与普通索引类似，但索引列的值必须唯一，允许有空值。 组合唯一索引：列值的组合必须唯一。 主键索引：特殊的唯一索引，用于唯一标识数据表中的某一条记录，不允许有空值，一般用primary key约束。 全文索引：用于海量文本的查询，MySQL5.6之后的InnoDB和MyISAM均支持全文索引。由于查询精度以及扩展性不佳，更多的企业选择Elasticsearch。 index optimization 分页查询很重要，如果查询数据量超过30%，MYSQL不会使用索引。 单表索引数不超过5个、单个索引字段数不超过5个。 字符串可使用前缀索引，前缀长度控制在5-8个字符。 字段唯一性太低，增加索引没有意义，如：是否删除、性别。 合理使用覆盖索引，如下所示： select loginname, nickname from member where login_name = ? loginname, nickname两个字段建立组合索引，比login_name简单索引要更快 sql优化batch当一条sql语句会处理整个表的数据的时候，有可能会堵塞其他sql运行1update status=0 FROMcoupon WHERE expire_date &lt;= #&#123;currentDate&#125; and status=1; 因此可以使用分批操作 optimization12345678910int pageNo = 1;int PAGE_SIZE = 100;while(true) &#123; List&lt;Integer&gt; batchIdList = queryList(&apos;select id FROM `coupon` WHERE expire_date &lt;= #&#123;currentDate&#125; and status = 1 limit #&#123;(pageNo-1) * PAGE_SIZE&#125;,#&#123;PAGE_SIZE&#125;&apos;); if (CollectionUtils.isEmpty(batchIdList)) &#123; return; &#125; update(&apos;update status = 0 FROM `coupon` where status = 1 and id in #&#123;batchIdList&#125;&apos;) pageNo ++;&#125; operation &lt;&gt; optimization通常&lt;&gt;操作符无法使用索引，举例如下，查询金额不为100元的订单：select id from orders where amount != 100;如果金额为100的订单极少，这种数据分布严重不均的情况下，有可能使用索引。鉴于这种不确定性，采用union聚合搜索结果，改写方法如下：1(select id from orders where amount &gt; 100) union all(select id from orders where amount &lt; 100 and amount &gt; 0) operation or optimization在Innodb引擎下or无法使用组合索引，比如：1select id，product_name from orders where mobile_no = &apos;13421800407&apos; or user_id = 100; OR无法命中mobileno + userid的组合索引，可采用union，如下所示：1(select id，product_name from orders where mobile_no = &apos;13421800407&apos;) union(select id，product_name from orders where user_id = 100); 此时id和product_name字段都有索引，查询才最高效。 operation in optimization IN适合主表大子表小，EXIST适合主表小子表大。由于查询优化器的不断升级，很多场景这两者性能差不多一样了。 尝试改为join查询，举例如下：123select id from orders where user_id in (select id from user where level = &apos;VIP&apos;);采用JOIN如下所示：select o.id from orders o left join user u on o.user_id = u.id where u.level = &apos;VIP&apos;; 不做列运算通常在查询条件列运算会导致索引失效，如下所示：查询当日订单1select id from order where date_format(create_time，&apos;%Y-%m-%d&apos;) = &apos;2019-07-01&apos;; date_format函数会导致这个查询无法使用索引，改写后：1select id from order where create_time between &apos;2019-07-01 00:00:00&apos; and &apos;2019-07-01 23:59:59&apos;; avoid Select all如果不查询表中所有的列，避免使用 SELECT *，它会进行全表扫描，不能有效利用索引。 operation like optimizationlike用于模糊查询，举个例子（field已建立索引）：1SELECT column FROM table WHERE field like &apos;%keyword%&apos;; 这个查询未命中索引，换成下面的写法：1SELECT column FROM table WHERE field like &apos;keyword%&apos;; 去除了前面的%查询将会命中索引，但是产品经理一定要前后模糊匹配呢？全文索引fulltext可以尝试一下，但Elasticsearch才是终极武器。 operation Join optimizationjoin的实现是采用Nested Loop Join算法，就是通过驱动表的结果集作为基础数据，通过该结数据作为过滤条件到下一个表中循环查询数据，然后合并结果。如果有多个join，则将前面的结果集作为循环数据，再次到后一个表中查询数据。 驱动表和被驱动表尽可能增加查询条件，满足ON的条件而少用Where，用小结果集驱动大结果集。 被驱动表的join字段上加上索引，无法建立索引的时候，设置足够的Join Buffer Size。 禁止join连接三个以上的表，尝试增加冗余字段。 oper Limit optimizationlimit用于分页查询时越往后翻性能越差，解决的原则：缩小扫描范围 ，如下所示：12select * from orders order by id desc limit 100000,10 耗时0.4秒select * from orders order by id desc limit 1000000,10耗时5.2秒 先筛选出ID缩小查询范围，写法如下：1select * from orders where id &gt; (select id from orders order by id desc limit 1000000, 1) order by id desc limit 0,10耗时0.5秒 如果查询条件仅有主键ID，写法如下：1select id from orders where id between 1000000 and 1000010 order by id desc耗时0.3秒 如果以上方案依然很慢呢？只好用游标了，感兴趣的朋友阅读JDBC使用游标实现分页查询的方法]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu best software]]></title>
    <url>%2Fubuntu%2Fbest_software.html</url>
    <content type="text"><![CDATA[cpu 内存 网速显示123456sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitorsudo apt-get updatesudo apt-get install indicator-sysmonitorindicator-sysmonitor 远程连接windos rdesktop teamview 百度云有linux版本]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sogou input method install]]></title>
    <url>%2Fubuntu%2FsogouInputMethod.html</url>
    <content type="text"><![CDATA[搜狗输入法安装 先添加源：sudo add-apt-repository ppa:fcitx-team/nightly 添加源之后更新一下：sudo apt-get update &amp;&amp; apt-get upgrade 开始安装fcitx: sudo apt-get install fcitx （可能系统已安装好），如果出现错误提示，就：apt-get -f install,然后再sudo apt-get install fcitx 安装fcitx的配置工具：sudo apt-get install fcitx-config-gtk 安装fcitx的table-all:sudo apt-get install fcitx-table-all 安装im-switch工具：sudo apt-get install im-switch 安装包 下载安装包，并且安装sudo dpkg -i sogoupinyin_2.2.0.0108_amd64.deb ，如果出现错误提示，就：apt-get -f install，再安装 到system settings-&gt;language support,将键盘输入法设置为fcitx 运行fcitx-configure 设置输入法，如果没有发现搜狗输入法，重启一次电脑]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>inputMethod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[license]]></title>
    <url>%2FsublimeText%2FsublimeText_license.html</url>
    <content type="text"><![CDATA[sublime text3 license]]></content>
      <categories>
        <category>sublimeText</category>
      </categories>
      <tags>
        <tag>license</tag>
        <tag>sublimeText</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[postgresql Learning resource map]]></title>
    <url>%2Fdatabases%2Fpostgresql%2FpostgresqlLearningResource.html</url>
    <content type="text"><![CDATA[postgresql Learning resource map引用ty4z2008 PostgreSQL(数据库)资料 About:PostgreSQL About 《PostgreSQL 源码分析系列》 PostgreSQL 源码分析系列 介绍:PostgreSQL 源码分析系列文章 《PG 内存上下文》 介绍：PG 内存上下文,code 《PostgreSQL及其代码的结构》 介绍:PostgreSQL及其代码的结构 《A Tour of PostgreSQL Internals》 介绍:PostgreSQL内部的概览,可以结合上面的pg代码结构来阅读 《PostgreSQL 中的 Json —从使用到源码》 介绍：PostgreSQL 中的 Json —从使用到源码 《PostgreSQL锁机制分析》 介绍：PostgreSQL锁机制分析,第二部分 《FSM》 介绍：PostgreSQL源码分析之FSM 《page》 介绍：PostgreSQL源码分析之page 《shared buffer状态信息及性能测量 》 介绍：PostgreSQL源码分析之shared buffer状态信息及性能测量,推荐shared buffer的分配与替换,shared buffer与磁盘文件 ,database和table 与磁盘文件的对应 《PostgreSQL内部结构与源代码研究索引页》 介绍：文章包括pg_stat_statements源代码分析,PostgreSQL的hook机制初步学习,EDB*Plus的client_encoding问题,PostgreSQL的索引膨胀,libpq 与 fe-misc.c,libpq 练习的入口点,Autovacuum 的运行限制,autovacuum 与 vacuum full,autoanalyze 的注意事项,backuplabel file 初步学习,HOT（Heap-Only Tuples）,Checkpoint 发生的时机,checkpoint 活动,pg_buffercache 代码研究,内存结构图示,内存使用增长观察,使用cgroups来控制内存使用,调整内存与IO的参数说明,MVCC图示,ListenSocket 的研究 《CreateLockFile》 介绍：PostgreSQL CreateLockFile分析 《动态Hash》 介绍：动态Hash 《Postgres Internals Presentations》 介绍: PG内部机制分析. 《为PostgreSQL添加插件》 介绍: 利用pg的hook机制为pg添加插件. 《PostgreSQL 优化器逻辑推理能力》 介绍: 源码解析. 《postgres 源码分析之 insert(1)》 介绍: Insert分析. 《PostgreSQL查询处理部分源码分析》 介绍: PostgreSQL查询处理部分源码分析. 《PostgreSQL查询处理部分源码分析》 介绍: PostgreSQL查询处理部分源码分析. 《Understanding caching in Postgres》 介绍:Postgres缓存机制分析. 《Discovering the Computer Science Behind Postgres Indexes》 介绍: Postgres索引分析,推荐先阅读Efficient Locking for Concurrent Operations on B-Trees. 《Estimating the Optimal Number of Latent Concepts in Source Code Analysis》 介绍:Estimating the Optimal Number of Latent Concepts in Source Code Analysis. 《Pgkernel》 介绍:Postgres内核分析系列文章 《PostgreSQL Documentation》 介绍：PostgreSQL官方文档主页 《PG技术沙龙ppt》 介绍：2013年4月PG技术沙龙PPT 《PG9.4.4中文翻译文档》 介绍：PG9.4.4中文翻译文档 《Database System Concepts Sixth Edition》 介绍：数据库系统概念(第六版) 《PostgreSQL从菜鸟到专家(中译稿 by 洞庭湖的泥鳅)》 介绍：这篇文档是国内的一线postgreSQL专家所翻译。很经典 《PostgreSQL vs. MS SQL Server》 介绍：PostgreSQL与 MS SQL Server的对比,中文版 《PostgreSQL 30天 培训视频》 介绍：作者德哥@Digoal从事pg截止目前大概有7-8年，长期活跃在国内的pg社区。这套PostgreSQL 30天 培训视频包含了SQL基础,备份恢复,HA,服务端编程,大数据,内核,应用案例等，非常适合新手 《PostgreSQL爱好者的参考资料推荐》 介绍：PostgreSQL爱好者的参考资料推荐 《PostgreSQL Studio》 介绍：PostgreSQL Studio 是开源的 PostgreSQL 数据库的 Web 接口。可以让你直接在浏览器上编辑数据库代码，浏览数据库模型和运行 SQL 语句。这是一个数据库管理工具，侧重于开发。 《PostgreSQL Query Cache》 介绍：PostgreSQL Query Cache 一个新的开源软件，用来极速提升 PostgreSQL 数据库的查询性能，通过缓存查询结果，可提升 10 ~ 100 倍。 《py-postgresql》 介绍：Python的PostgreSQL驱动。 《Postgres-XL》 介绍： 一个构建PostgreSQL集群开源软件,Postgres-XL is a PostgreSQL-based scale-out cluster that handles both OLTP write intensive workloads as well as OLAP/BI type of workloads thanks to MPP parallelism.。 《pgDesigner》 介绍：pgDesigner 是一个为PostgreSQL数据库设计的建模工具.仅支持Linux。 《pgweb》 介绍：一个采用 Go 语言开发的基于 Web 的 PostgreSQL 管理系统。 《pgwatch》 介绍：一个简单易用的 PostgreSQL 的监控工具，支持 PostgreSQL 9.0 以及更新的版本。 《pgpool-II》 介绍：pgpool-II 是运行于 PostgreSQL 数据库服务器和客户端之间的一个中间件，提供的功能包括：连接池、复制、负载均衡、客户端限制和并行查询等。 《pgCluu》 介绍：pgCluu 是一个对 PostgreSQL 集群性能进行完整审计的工具，该工具分为两部分： collector 收集器用于从 PostgreSQL 集群中获取统计数据，使用 psql 和 sar 工具 grapher 关于生成 HTML 报表和图表 数据库服务器和客户端之间的一个中间件，提供的功能包括：连接池、复制、负载均衡、客户端限制和并行查询等。 《cstore_fdw》 介绍：cstore_fdw 实现了 PostgreSQL 数据库的柱状存储，用于对批量加载的数据进行分析的场景。 《Barman for PostgreSQL》 介绍：Barman (备份和恢复管理器) for PostgreSQL 是 PostgreSQL 数据库服务器的灾难恢复工具，允许远程备份多个服务器，帮助 DBA 在数据恢复阶段的关键工作。 《pgFouine》 介绍：pgFouine 是一个 PostgreSQL 的日志分析软件，可以让你对 PostgreSQL 数据库的运行状态有个清晰的了解，同时对一些慢查询、使用频率最高的查询、错误生成相应的报表和图表。 《Substitute PostgreSQL for Your NoSQL Needs》 介绍：用PostgreSQL替换你的NoSQL。 《Representing Trees in PostgreSQL》 介绍：Representing Trees in PostgreSQL 《Michael Paquier》 介绍：推荐一个博客，作者是一位日本的开发者。但是文章写的挺好的。是英文！！ 《Using Writeable CTEs to Improve Performance in PostgreSQL 》 介绍：使用CTEs来提升你的数据库性能 《Fast pagination on PostgreSQL》 介绍：PostgreSQL的快速分页 《Upgrading your PostgreSQL cluster from 9.3 to 9.4 》 介绍：把你的PostgreSQL集群从9.3升级到9.4. 《Making PostgreSQL scale Hadoop-style: Benchmark numbers》 介绍：Making PostgreSQL scale Hadoop-style: Benchmark numbers 《So You Want Another PostgreSQL Database？》 介绍：还有part2 《PostgreSQL Rising》 介绍：PostgreSQL的成长 《Simple API with Nginx and PostgreSQL》 介绍：如何建一个简单的REST API 仅仅使用 Nginx 和 PostgreSQL.如果不理解REST API这里推荐RESTful API 设计指南、理解RESTful架构 《hypervault》 介绍：PostgreSQL connection manager for scalability freaks. 《PostgreSQL as a benchmarking tool》 介绍：PostgreSQL as a benchmarking tool 《2014年 PGcon会议paper》 介绍：2014年 PGcon会议paper，进去之后你还可以发现往年的paper。 《PSequel》 介绍： Mac OS X端的PostgreSQL图形管理工具 《PostgreSQL’s Powerful New Join Type:LATERAL》 介绍： PostgreSQL’s Powerful New Join Type: LATERAL，这个类型是在9.3的版本中开始的。 《PostgreSQL Hardware Performance Tuning》 介绍：PostgreSQL的硬件性能调优。 《PostgreSQL: Introduction and Concepts Bruce Momjian》 介绍：入门型电子书籍,书有点老了2001年的了。此外这本书的作者还有一个资源页，里面有很多的干货。作者是enterpriseDB的工程师。经典文章还有Writing PostgreSQL Applications. 《Compiling PLV8 with Postgres Plus Advanced Server》 介绍：什么是PLV8？,魅力就是:用js写SQL 《fosdem 2014年PostgreSQL议题(含视频)》 介绍:fosdem是一个开源性组织,这个只是会议的一部分，从2001年开始到目前历经13年的资料都被保存着，如果你有需要可以自己去翻阅。干货很多，另外2015年的议题已经开始筹备了官方地址 *《PostgreSQL Now Has Logical Decoding》 介绍：PostgreSQL Now Has Logical Decoding,此外作者也是一位enterpriseDB的工程师，他的其他博文也很精彩. 《美国2014年pgconf paper》 介绍：美国2014年pgconf paper。 《mysql2postgres》 介绍：把MySQL迁移至postgreSQL?不如试试这个工具吧 《What are the advantages and disadvantages of using PostgreSQL over MySQL?》 介绍：使用PG与MySQL比较有那些有点和缺点？ 《Postgres full-text search is Good Enough!》 介绍：Postgres的全文查询其实也很棒：多语言支持，模糊查询等，这篇文章说的很详细。而且里面有很多实际例子 《PostgreSQL Security Audit》 介绍：数据库安全问题一直是一个问题热门话题，PostgreSQL资料更是少之有少。这篇文章值得推荐。建议多多留意postgresql security Vulnerabilities、Vulnerability handling in the PostgreSQL project、Security for PostgreSQL explain plans、Row security in PostgreSQL 《使用oracle_fdw进行增量数据迁移的神奇方法》 介绍:Oracle增量数据迁移到postgres方法，此外博主还有其他非常棒的文章。推荐也可以看看 《Ware Yosemite? Possible PostgreSQL upgrade issues in OS X 10.10》 介绍:PostgreSQL升级在 Yosemite出现问题？可以参考一下这里。同样的也还有其他的文章也很不错 《Open source developer based in Japan》 介绍:如题，是日本一个开源项目博客，里面有很多postgresql的最新特性介绍(截止目前2014.12.13已有pg9.5的特性预览了) 《PGXN: PostgreSQL Extension Network》 介绍:一个存放PostgreSQL扩展库的资源库,很多扩展插件都能够在这个里面找到 《GP GPU Accelerates PostgreSQL》 介绍：GPU对pg数据库的加速优化 《Porting Oracle Applications to PostgreSQL》 介绍：从Oracle迁移到pg，此外该作者还有一篇迁移的ppt. 《Building and Distributing PostgreSQL Extensions Without Learning C》 介绍：即使没有C，你也可以扩展pg 《PagerDuty analytics with Postgres》 介绍：使用PagerDuty做pg分析 《Syncing Postgres to Elasticsearch: lessons learned》 介绍：Elasticsearch是一个实时的分布式搜索和分析引擎,这篇文章是讲述作者在做pg同步到Elasticsearch的时候的一些经验之谈，如果有相关需要的建议阅读．如果不明白什么是Elasticsearch，可以先看看Elasticsearch权威指南 《pypgTAP》 介绍：Making Postgres coding and testing fun! 《Backuping PostgreSQL with Docker》 介绍：备份基于Docker的PostgreSQL数据库,国内有中文版 《postgresql 9.0 memory processes》 介绍：PostgreSQL 9.0 内存 &amp; 进程，感觉英语吃力的朋友可以阅读中文版 《postgresql 9.0 architecture》 介绍： 本篇文章讲述了PostgreSQL 9.0 构架，中文版 《Deadlocks in PostgreSQL》 介绍： PostgreSQL中的死锁，中文版 《PostgreSQL 9.0 Backup &amp; Recovery》 介绍： 本篇文章讲述了PostgreSQL 9.0 备份 &amp; 恢复架，中文版 《将数据从PostgreSQL同步到Elasticsearch的经验总结》 介绍： 将数据从PostgreSQL同步到Elasticsearch的经验总结 《数据库相论文推荐》 介绍： 索引，查询，磁盘，优化，挖掘，集群，数据恢复，高可用，高性能等等，这些仅仅是一部分而已，在主页上面有2014年一年的数据库相关论文 《pgloader》 介绍： postgresql的一数据导入工具，支持csv, 数据迁移 《mysql schema to postgresql》 介绍：Converter mysql schema and data to postgresql 《Search PostgreSQL sites》 介绍：一个PostgreSQL资料搜索引擎. 《PostgreSQL Tutorial》 介绍：一个PostgreSQL入门教程站点，新手上路. 《PostgreSQL: CLUSTER table USING index》 介绍：对CLUSTER表使用索引. 《When Postgres will not start》 介绍：当数据库无法启动的时候,我们应该如何做. 《Postgres and Connection Pooling》 介绍：作者的博客还有很多干货. 《PgBouncer》 介绍：PGBouncer是一个轻量级的针对PostgreSQL的数据库连接池工具，能够给客户端提供一个统一的链接视图. 《PGQ 》 介绍：PGQ is the queueing solution from Skytools. The Londiste replication solution is a consumer daemon built on PGQ, and the API is accessible for you to create any asynchronous processing facility, based on queuing.github. 《Implementing High Availability with PostgreSQL》 介绍：实现一个高可用PostgreSQL集群,YoutuBe上更多PostgreSQL cluster视频. 《numtel:pg》 介绍：Reactive PostgreSQL for Meteor. 《Slow PostgreSQL Performance? Don’t Forget to Vacuum your Database》 介绍：数据库性能优化之Vacuum. 《select * from depesz;》 介绍：里面有很多pg的最新资料,例如新版本的功能,技巧等. 《BDR 0.10.0 Documentation》 介绍：BDR新的文档,使用的数据库版本是9.4的,BDR可以帮助你更好的建立一个pg集群. 《Managing big enough data in postgres》 介绍：pg中的大规模数据管理经验. 《Database System Concepts Sixth Edition》 介绍：耶鲁大学的数据库系统概念课件. 《Hooks in PostgreSQL》 介绍：PostgreSQL的hook机制介绍.如果有困难可以先看看简单的使用介绍，此外这位博主的其他pg文章也不错. 《The design of the postgres storage system》 介绍：Postgres存储系统设计论文. 《The design of the postgres》 介绍：Postgres设计论文. 《The Design of the POSTGRES Rules System》 介绍：The Design of the POSTGRES Rules System. 《PostgreSQL官方推荐文献》 介绍：PostgreSQL官方推荐文献. 《Anatomy of a Database System》 介绍：数据库内部结构剖析. 《PGtune》 介绍：PostgreSQL性能调优工具,只需要输入机器配置即可获得相应的推荐优化参数. 《PostgreSQL performance considerations》 介绍：很多讲 PostgreSQL 优化的文章都提到了 Partial indexesPartial indexes，简单的说，它是一个通过 WHERE 过滤后的子集数据的索引，虽然 MySQL 里也有这个名词，但完全不是一个东西。案例：㈠ Handling Growth with Postgres: 5 Tips From Instagram ㈡ Speeding Up PostgreSQL With Partial Indexes. 《Postgres Guide》 介绍：Postgres的指南主要强调在Postgre存在的最佳实践和强大的功能. 《PostgreSQL Performance Tuning》 介绍：PostgreSQL性能调优,作者的其他关于PostgreSQL文章也不错. 《PostgreSQL Backend Flowchart》 介绍： PostgreSQL 内核学习. 《PostgreSQL Vulnerability》 介绍： PostgreSQL漏洞库. 《Full text search in milliseconds with PostgreSQL》 介绍： PostgreSQL毫秒级全文本搜索. 《Annotated postgresql.conf and Global User Configuration (GUC) Guide》 介绍： postgresql.conf配置文件注释. 《Bottled Water: Real-time integration of PostgreSQL and Kafka》 介绍：利用Postgres 9.4的新功能Logical Decoding，实时stream所有SQL操作到Kafka，然后下游的各种consumer从Kafka中接收。其实就是Write-ahead logging的广义应用 《Is PostgreSQL Your Next JSON Database?》 介绍： Is PostgreSQL Your Next JSON Database?. 《NoSQL with PostgreSQL 9.4 and JSONB》 介绍： NoSQL with PostgreSQL 9.4 and JSONB. 《PostgreSQL, the NoSQL Database》 介绍： PostgreSQL, the NoSQL Database. 《How to update large tables in PostgreSQL》 介绍： PostgreSQL如何更新大表. 《PostgreSQL:Error Message Style Guide》 介绍： PostgreSQL错误信息编码指南. 《Compressing PostgreSQL JSONB data 12x using cstore_fdw》 介绍： cstore_fdw压缩PostgreSQL数据. 《PostgreSQL: the good, the bad, and the ugly》 介绍： PostgreSQL评价. 《SQLPro for PostgresSQL》 介绍： Mac OS X上的PostgreSQL管理器. 《PostgreSQL 9.5’s Upsert Feature Explained》 介绍: PostgreSQL 9.5新特性Upsert解释 . 《PostgreSQL database replication》 介绍:PostgreSQL的复制. 《YeSQL: Battling the NoSQL Hype Cycle with Postgres》 介绍： YeSQL: Battling the NoSQL Hype Cycle with Postgres,博客的其他内容也不错. 《pgTAP》 介绍:pgTAP is a unit testing framework for PostgreSQL written in PL/pgSQL and PL/SQL. 《Practical PostgreSQL》 介绍: 免费的pg电子书《PostgreSQL实践》,书虽然有点老,但是很多知识点是可以通用的. 《PostgreSQL: Introduction and Concepts》 介绍:PostgreSQL介绍与入门,免费在线电子书,pdf版,入门的还有Get to know PostgreSQL. 《Mastering PostgreSQL Administration》 介绍:PostgreSQL管理入门,非常全,此外作者写了很多关于pg的ppt和文档,也很精彩. 《Postgres-XC》 介绍: Postgres-XC 是一种提供写可靠性,多主节点数据同步,数据传输的开源集群方案. 《PGCon 2015 演讲稿》 介绍: PGCon 2015 演讲稿下载. 《PostgreSQL Shutdown》 介绍: PG停止服务评析. 《First Rule in Securing Postgres: Don’t Be Dumb》 介绍: pg的安全规则建议,共5点,第一点就是Don’t be dumb!,enterprisedb的官方博客资源还真的比较丰富,例如还有中文版的Postgres Plus Advanced Server与oracle兼容文档. 《Serializable Snapshot Isolation in PostgreSQL》 介绍: PG中的可串行化快照隔离. 《Converting from other Databases to PostgreSQL》 介绍: 其他数据库向psotgresql迁移数据的工具,官方出品，包括 MySQL, MS SQL Server, SQL Azure, Oracle, MS Access.等. 《深度学习PostgreSQL》 介绍: 从安装到双机热备再到内核分析,内容丰富网盘提取密码fmby. 《Postgres CLI with autocompletion and syntax highlighting》 介绍: pgcli是一个PostgreSQL命令行工具,提供了语法高亮以及自动补全的功能. 《Postgres Guid》 介绍: Postgres入门指南,从安装到优化,也讲到了非标准数据类型JSON,hstor等. 《Efficient Use of PostgreSQL Indexes》 介绍: 本文介绍了如何高效的使用pg的索引,很详细.讲到了很多容易被初学者容易疏忽的地方. 《PostgreSQL学习手册(目录)》 介绍: PostgreSQL学习手册,虽然是2012年的,但里面的内容与现在的最新版pg是兼容,可以正常使用的. 《”Big data” features coming in PostgreSQL 9.5》 介绍: PostgreSQL9.5中对于大数据的有利特性介绍. 《PostgreSQL-The Bits You Haven’t Found》 介绍: PostgreSQL中可能你还不知道的秘密,可以用作知识梳理. 《Designing A PostgreSQL Document API》 介绍: 自己动手设计一个PostgreSQL文档api. 《10 beginner’s PostgreSQL tasks you should know》 介绍: PostgreSQL初学者快速入门要点. 《SQL vs NoSQL KO. Postgres vs Mongo》 介绍: 关系型数据库Postgres vs NoSQL 数据库Mongo的对决,这篇文章比较客观. 《EnterpriseDB认证通关攻略》 介绍:如果你想考EnterpriseDB认证,推荐阅读此篇文章. 《sql_firewall: a SQL Firewall Extension for PostgreSQL》 介绍:这个插件可以更好的帮助你防御黑客攻击你的数据库. 《Aquameta Layer 0: meta - Writable System Catalog for PostgreSQL》 介绍:Aquameta的pg实践. 《Postgres Weekly》 介绍:国外的PostgreSQL周刊,每周的pg新鲜事. 《PostgreSQL, pg_shard, and what we learned from our failures》 介绍:pg_shard的经验分享. 《REST API for any Postgres database》 介绍:pg的一个非官方REST API,此外推荐RADIP RESTful API for PostgreSQL. 《Pg_clog异步提交一致性、原子操作与fsync》 介绍:Pg_clog分析. 《Pg的checkpoint的调度》 介绍:同步机制分析. 《PostgreSQL Foreign Data Wrappers》 介绍:PostgreSQL外部数据封装器介绍. 《Following a Select Statement Through Postgres Internals》 介绍:SELECT查询如何在PostgreSQL内部工作的. 《PipelineDB—The Streaming SQL Database》 介绍:PipelineDB是基于PostgreSQL研发的一种流式关系数据库. 《PostgreSQL：A Platform for Multiple Sources Data Retrieval》 介绍:使用pg完成多平台数据源检索,幻灯片. 《Column-Stores vs. Row-Stores: How Different Are They Really?》 介绍:列式存储与行式存储数据库之间究竟有何区别？. 《Pivotal Greenplum Database has been open sourced》 介绍:基于PostgreSQL的Greenplum Database数据仓库开源. 《PostgreSQL 数据库文档》 介绍:PostgreSQL数据库文档,文档内容基于9.5版本演示. 《More Concurrency: Improved Locking In PostgreSQL》 介绍:pg高并发在锁方面的改善，中文版. 《SQL Tabs 》 介绍:PostgreSQL的跨平台终端. 《Writing Postgres Extensions - Debugging》 介绍:PostgreSQL插件开发. 《PostgreSQL: A full text search engine》 介绍:PostgreSQL全文搜索引擎剖析part2,part3. 《PostgreSQL-Consulting.com》 介绍:这是一个PG商业顾问的博客，里面提供的pg性能调优，部署，迁移等博文. 《PostgreSQL Planet》 介绍:PostgreSQL官方的一个pg文章news. 《Benchmarking Postgres-XL》 介绍:Postgres-XL压力测试分析,博客中的其他内容也很有料. 《PostgreSql Database Video Tutorials》 介绍:PostgreSQL视频教程. 《PostgreSQL Replication Tutorial》 介绍：PostgreSQL Replication Tutorial 《ngx_postgres》 介绍:nginx访问Postgresql模块 《How PostgreSQL Processes a Query》 介绍:pg是如何处理一个查询的？ 《Common misconceptions about locking in PostgreSQL》 介绍:pg中容易误解的锁 《PostgreSQL Big SQL commponent》 介绍:pg大数据工具箱 《PostgreSQL 9.3.4 文档》 介绍:PostgreSQL 9.3.4 文档翻译,作者是《postgresql内核分析》作者 《pglogical：A logical replication system for PostgreSQL》 介绍:pg的逻辑复制扩展,兼顾了基于触发器复制技术的灵活性,同时又有基于日志复制技术的高效性 《Postgres EXPLAIN Visualizer》 介绍:Postgres的EXPLAIN查看执行计划已经非常的直观、全面，不过有人更钟情于图形化的展示，现在有了这样一个项目就是干这个的：Postgres EXPLAIN Visualizer (Pev)。 《Custom Aggregates in PostgreSQL》 介绍:在写复杂的SQL时，可能会进行复杂的运算.但是原有的聚集函数并不能满足要求。这篇文章详细介绍了自定义聚集函数 《Performance Tuning Queries in PostgreSQL》 介绍:pg性能调优之数据查询,此外推荐https://www.youtube.com/watch?v=svqQzYFBPIo 《Building Full Text Search For Your Application using Postgres》 介绍:使用pg为自己的应用构建全文检索 《PostgreSQL SQL Injection Cheat Sheet》 介绍:PostgreSQL SQL注入手册 《PostgreSQL Query Optimization》 介绍:PostgreSQL查询优化，比较新手，但是你得有点基本的优化基础。否则会看起来很吃力 《A Tour of PostgREST》 介绍:PostgreSQL RESTful教程 《PostgreSQL’s explain analyze made readable》 介绍:可视化PostgreSQL执行计划,pg学习看执行计划的好资料 《PostgreSQL HA Database Clusters through Containment》 介绍:pg HA数据库集群分析 《PostgreSQL 9.6 New Features With Examples》 介绍:PostgreSQL9.6新特性 《Understanding EXPLAIN》 介绍:深入学习PostgreSQL的explain工具 《PostgreSQL Exercises》 介绍:PostgreSQL学习实验室，有练习。适合新手入门pg 《On Uber’s Choice of Databases》 介绍:文章诞生于Uber发表的一篇关于从pg迁移到mysql的文章，国内与国外讨论甚广.在讨论过程中诞生了很多精彩的干货，值得一读。学习数据库要深入，并存的世界才是和平.推荐为PostgreSQL讨说法 - 浅析《UBER ENGINEERING SWITCHED FROM POSTGRES TO MYSQL》 《Advanced Postgres Performance Tips》 介绍:高级PostgreSQL性能调优 《PostgreSQL Index Internals》 介绍:索引的内部原理,推荐2016年欧洲pg大会资料涵盖ppt与视频 《PGLiveBackup》 介绍:pg数据库自动全量备份脚本. 《pg_paxos:Basic implementation of Paxos and Paxos》 介绍:分布式算法Paxos的pg实践，可以先通过PPT.它实现了基本的Multi-Paxos和Paxos. 《Database Hardware Selection Guidelines》 介绍:数据库硬件选择指南,主要是一个参考.推荐Database Hardware Selection Guidelines 《pglogical:Logical Replication extension for PostgreSQL》 介绍:PostgreSQL逻辑复制扩展. 《PostgreSQL: Introduction and Concepts》 介绍:PostgreSQL的历史书. 《How Twitch uses PostgreSQL》 介绍:PostgreSQL在twitch的应用. 《pg_monz:PostgreSQL monitoring template for Zabbix》 介绍:PostgreSQL的Zabbix监控模版. 《pgclusteradmin:PostgreSQL cluster manager base on Golang》 介绍:一款基于go开发的Postgresql集群管理工具 《PgHero:PostgreSQL performance monitoring tool》 介绍:基于Ruby开发的PostgreSQL性能监控Web平台，支持SQL查询历史记录，实时连接数监控,SQL分析,性能调优推荐,Tune是基于pgtune 《GiST for PostgreSQL》 介绍:PostgreSQL的GiST（通用搜索树）核心开发作者主页. 《Postage - A fast replacement for PGAdmin》 介绍:PGAdmin的替代工具.里面有一个比较实用的功能就是可以逆向表成关系图 《Postgres EXPLAIN Visualizer (pev)》 介绍:Postgres 执行计划可视化工具 《PostgreSQL workings in one picture》 介绍:一张图了解PostgreSQL工作结构 《Postgres Indexes Under the Hood》 介绍:Postgres索引的底层运行机制 《Annotated Config Files for PostgreSQL》 介绍:PostgreSQL配置文件注释篇，详细介绍每个参数的意思，其中postgresql.10.simple.conf为必须修改项，extra.10.conf为可能要修改的项。 《pgBackRest:Reliable PostgreSQL Backup &amp; Restore》 介绍:pgBackRest支持并行备份和恢复，增量备份。对于大规模pg数据库备份与同步很有帮助 《PostgreSQL Related Slides and Presentations》 介绍:PostgreSQL相关演讲资料。包括一些pgconf会议PPT。 《Awesome Postgres》 介绍:Awesome系列，高可用、备份、管理、打包版本、命令行、监控、扩展、优化、工具、API、以及一些比较不错的博文、例如Debugging PostgreSQL performance, the hard way 《The Internals of PostgreSQL》 介绍:一本关于PG数据库管理员运维的书，主要围绕着集群、备份、Buffer、索引、复制. 《Understanding the power of data types: PostgreSQL’s Secret Weapon》 介绍:了解数据类型的力量：PostgreSQL的秘密武器. 《PostgreSQL Backend Flowchart》 介绍:PostgreSQL的后台执行流程图,对于阅读源码或者是想了解内部的构成可以先阅读。]]></content>
      <categories>
        <category>postgresql</category>
      </categories>
      <tags>
        <tag>postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[common cmd]]></title>
    <url>%2Fshell%2Fcommon_cmd.html</url>
    <content type="text"><![CDATA[common cmddelete all files in the current path except file A1234find ./* |grep -v A |xargs rm -r# second methodrm -rf !(keep1 | keep2) delete all file except py file1find . -name &quot;*&quot; -type f |grep -v &quot;.py&quot; |grep &quot;\.&quot; |xargs rm -rf kill all python process1ps -ef|grep python |grep -v grep|awk &apos;&#123;print $2&#125;&apos;|xargs kill -9 bash shortkey Ctrl + l ：清除屏幕，同clear Ctrl + a ：将光标定位到命令的开头 Ctrl + e ：与上一个快捷键相反，将光标定位到命令的结尾 Ctrl + u ：删除当前命令 Ctrl + k ：与上一个快捷键相反，剪切光标之后的内容 Ctrl + y ：粘贴以上两个快捷键所剪切的内容。Alt+y粘贴更早的内容 Ctrl + w ：删除光标左边的参数（选项）或内容（实际是以空格为单位向前剪切一个word） Ctrl + / ：撤销，同Ctrl+x + Ctrl+u Ctrl + f ：按字符前移（右向），同→ Ctrl + b ：按字符后移（左向），同← Alt + f ：按单词前移，标点等特殊字符与空格一样分隔单词（右向），同Ctrl+→ Alt + b ：按单词后移（左向），同Ctrl+← Alt + d ：从光标处删除至字尾。可以Ctrl+y粘贴回来 Alt + \ ：删除当前光标前面所有的空白字符 Ctrl + d ：删除光标处的字符，同Del键。没有命令是表示注销用户 Ctrl + h ：删除光标前的字符 Ctrl + r ：逆向搜索命令历史，比history好用 Ctrl + g ：从历史搜索模式退出，同ESC Ctrl + p ：历史中的上一条命令，同↑ Ctrl + n ：历史中的下一条命令，同↓ Alt + .：同!$，输出上一个命令的最后一个参数（选项or单词）。 还有如Alt+0 Alt+. Alt+.，表示输出上上一条命令的的第一个单词（即命令）。 另外有一种写法 !:n，表示上一命令的第n个参数，如你刚备份一个配置文件，马上编辑它：cp nginx.conf nginx.conf，vi !:1，同vi !^。!^表示命令的第一个参数，!$最后一个参数（一般是使用Alt + .代替）。]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[www trace request test]]></title>
    <url>%2FITsecure%2Fwww_trace_request.html</url>
    <content type="text"><![CDATA[远程WWW服务支持TRACE请求test method ‘’’ http curl -v -X TRACE http://www.yourserver.com https curl –insecure -v -X TRACE https://www.yourserver.com ‘’’ return msg is “HTTP/1.1 405 Method Not Allowed” It works]]></content>
      <categories>
        <category>ITsecure</category>
      </categories>
      <tags>
        <tag>apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码审计-企业级web代码安全架构]]></title>
    <url>%2FITsecure%2Fcode%20audit%20Notes.html</url>
    <content type="text"><![CDATA[code audit Notescode audit env builtphp env install phpStudy 用于做技术探针，集成了所有php运行的环境，apache nginx php core secure configure register_globals 全局变量注册开关 allow_url_include 是否运行包含远程文件 include() magic_quotes_gpc 魔术引号自动过滤 filter get post cookie but $_SERVER ver 5.4 later abandon magic_quotes_runtime 魔术引号自动过滤 filter database or file ver 5.4 later abandon magic_quotes_sybase 魔术引号自动过滤 like magic_quotes_gpc safe_mode 安全模式 限制文件操作 限制函数执行和外部命令执行 open_basedir PHP可访问目录 disable_functions 禁用函数 phpinfo,eval,assthru,exec,system display_errors 和 error_reporting 错误显示 audit auxiliary tool or defect verification toolcode audit tool seay only for php Fortify SCA RIPS only for php defect verification tool burp suite]]></content>
      <categories>
        <category>ITsecure</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>secure</tag>
        <tag>audit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP dangerous function]]></title>
    <url>%2Fphp%2Fsecure%2Fphp_dangerous_function_unsafe_regular_expression.html</url>
    <content type="text"><![CDATA[PHP dangerous functionsplit1explode]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>web attack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP XSS]]></title>
    <url>%2Fphp%2Fsecure%2Fphp_XSS.html</url>
    <content type="text"><![CDATA[PHP XSSPersistent1echo htmlspecialchars($data, ENT_QUOTES); 1echo "location.replace("/index/'.urlencode($type).'");"]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>web attack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[open redirect]]></title>
    <url>%2Fphp%2Fsecure%2FOpen_Redirect.html</url>
    <content type="text"><![CDATA[open redirect1header("Location: $url"); solution1header("Location: ".filter_var($url, FILTER_SANITIZE_URL));]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>web attack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php possible variable overwrite global scope]]></title>
    <url>%2Fphp%2Fsecure%2Fphp_Possible_variable_overwrite_Global_scope.html</url>
    <content type="text"><![CDATA[php password Management Empty Password1extract($rows[0]); solution1extract($rows[0], EXTR_SKIP);]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>web attack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php password Management Hardcoded Password]]></title>
    <url>%2Fphp%2Fsecure%2Fphp_password_Management_Hardcoded_password.html</url>
    <content type="text"><![CDATA[php password Management Hardcoded Password123$tmp = array( "password"=&gt;"**********"); solution123$tmp = array( "password"=&gt;strval("*******"),);]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>web attack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php password Management Empty Password]]></title>
    <url>%2Fphp%2Fsecure%2Fphp_password_Management_Empty_Password.html</url>
    <content type="text"><![CDATA[php password Management Empty Password123$tmp = array( "password"=&gt;""); solution123$tmp = array( "password"=&gt;strval(null),);]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>web attack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE compatible]]></title>
    <url>%2Fjs%2FIECompatible.html</url>
    <content type="text"><![CDATA[jQuery().html() and interHtml method run very slowly on IE 8 or IE 9 browserphenomenonwhen run the method below, It costs too much time.123var htmlString = "&lt;div&gt;&lt;span&gt;test&lt;/span&gt;&lt;/div&gt;";jQuery().html(htmlString)domcument.getElementById().interHtml = htmlString; solutionreplace jQuery.html() or interHtml with dom method to solve the problem12345678910var htmlString = "&lt;div&gt;&lt;span&gt;test&lt;/span&gt;&lt;/div&gt;";//turn the string into a dom object var domObj = jQuery(htmlString).get(0);var el = document.getElementById(); var childs = el.childNodes; for(var i = childs .length - 1; i &gt;= 0; i--) &#123; //delete all child node el.removeChild(childs[i]);&#125;document.getElementById().appendChild(domObj); JSON module missingphenomenonsuch as JSON.parse or JSON.stringify method cant use solutiondownload the json2.js or json3.js, and import &lt;script src=&quot;/js/json3.min.js&quot;&gt;&lt;/script&gt; str.trim() missingsolutionreplace str.trim() with jQuery.trim(); jQuery().width() method calculates the error widthsolutionreplace jQuery.outerWidth() width jQuery().width()]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js将div截图发送到后台生成图片]]></title>
    <url>%2Fjs%2Fhtml2cavas.html</url>
    <content type="text"><![CDATA[html2canvas需要导入html2canvas.min.js1234567891011121314151617181920212223242526272829303132333435var oDiv = document.getElementById('div');var opts = &#123; scale:10, width:oDiv.offsetWidth, height:oDiv.offsetHeight&#125;;try&#123; html2canvas(oDiv, opts).then(function(canvas)&#123; canvas.getContext('2d').mozImageSmoothingEnabled = false; canvas.getContext('2d').webkitImageSmoothingEnabled = false; canvas.getContext('2d').msImageSmoothingEnabled = false; canvas.getContext('2d').imageSmoothingEnabled = false; var strDataURI = canvas.toDataURL(); var location_url = "/download/" param = &#123;'img':strDataURI&#125;; new Ajax.Request(location_url, &#123; method:'post', parameters:param, onComplete:function(req)&#123; window.location=location_url; &#125; &#125;); &#125;);&#125;catch(err)&#123; jQuery("#export").show(); var location_url = "/download/" param = &#123;&#125;; new Ajax.Request(location_url, &#123; method:'post', parameters:param, onComplete:function(req)&#123; window.location=location_url; &#125; &#125;);&#125; server12345678public function download()&#123; $img = $_POST['img']; $file = "/tmp.png"; $img = str_replace('data:image/png;base64,', '', $img); $img = str_replace(' ', '+', $img); $data = base64_decode($img); file_put_contents($file, $data);&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js Note]]></title>
    <url>%2Fjs%2Fnote.html</url>
    <content type="text"><![CDATA[javascript Notesjquery attr and prop 对于HTML元素本身就带有的固有属性，在处理时，使用prop方法。 对于HTML元素我们自己自定义的DOM属性，在处理时，使用attr方法。 12345678//像checkbox，radio和select这样的元素，选中属性对应“checked”和“selected”，这些也属于固有属性，因此需要使用prop方法去操作才能获得正确的结果。$("#chk1").prop("checked") == false$("#chk2").prop("checked") == true//如果上面使用attr方法，则会出现：$("#chk1").attr("checked") == undefined$("#chk2").attr("checked") == "checked" deep copy12345678910111213//深复制function copy(obj1,obj2)&#123; var obj2=obj2||[]; for(var name in obj1)&#123; if(typeof obj1[name] === &quot;object&quot;)&#123; obj2[name]= (obj1[name] instanceof Array)?[]:&#123;&#125;; copy(obj1[name],obj2[name]); &#125;else&#123; obj2[name]=obj1[name]; &#125; &#125; return obj2;&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python secure]]></title>
    <url>%2Fpython%2Fpython_secure.html</url>
    <content type="text"><![CDATA[防止命令注入使用subprocess1234cmd = [&apos;ls&apos;, &apos;-al&apos;]p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)data = &apos;&apos;.join(p.stdout.readlines())p.stdout.close() 替换shell的管道符1234567# output = `dmesg | grep hda`p1 = subprocess.Popen([&apos;dmesg&apos;], stdout=PIPE)p2 = subprocess.Popen([&apos;grep&apos;, &apos;hda&apos;], stdin=p1.stdout, stdout=PIPE)p1.stdout.close()output = p2.communicate()[0] 防止sql注入test 1’ or ‘1’ = ‘1 sqlmap 12sql_cmd = &quot;select * from ?&quot;cur.execute(sql_cmd, (table_name, )) 输入参数作为动态代码运行python eval exec pickle.loads cPickle.loads marshal.loads yaml.load php eval asset() preg_replace + ‘e’ call_user_func, call_user_func_array, create_function array_map 目录穿越 过滤掉. and .. os.path.basename(filename) 安全上传文件 文件后缀过滤 文件大小过滤-最大最小 文件名随机化 上传目录随机化]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>secure</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu notes]]></title>
    <url>%2Fubuntu%2Fubuntu_notes.html</url>
    <content type="text"><![CDATA[How to delete dash app label /usr/share/applications（全局模式下） ~/.local/share/applications（用户独立配置） compare expiredrm /home/agu/.config/bcompare/registry.dat zip 解压文件里面有中文乱码unzip -O CP936 xxxx.zip]]></content>
      <categories>
        <category>zsh</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP My Cookbook]]></title>
    <url>%2Fphp%2Fphp_My_cookbook.html</url>
    <content type="text"><![CDATA[判断变量是否为空empty() 函数用于检查一个变量是否为空。 empty() 判断一个变量是否被认为是空的。当一个变量并不存在，或者它的值等同于 FALSE，那么它会被认为不存在。如果变量不存在的话，empty()并不会产生警告。 empty() 5.5 版本之后支持表达式了，而不仅仅是变量。 版本要求：PHP 4, PHP 5, PHP 7 语法bool empty ( mixed $var ) 参数说明： $var：待检查的变量。 注意：在 PHP 5.5 之前，empty() 仅支持变量；任何其他东西将会导致一个解析错误。换言之，下列代码不会生效： empty(trim($name)) 作为替代，应该使用: trim($name) == false empty() 并不会产生警告，哪怕变量并不存在。 这意味着 empty() 本质上与 !isset($var) || $var == false 等价。 返回值当 var 存在，并且是一个非空非零的值时返回 FALSE 否则返回 TRUE。 以下的变量会被认为是空的： “” (空字符串) 0 (作为整数的0) 0.0 (作为浮点数的0) “0” (作为字符串的0) NULL FALSE array() (一个空数组) $var; (一个声明了，但是没有值的变量) 实例1234567891011121314151617181920&lt;?php$ivar1=0;$istr1=&apos;Runoob&apos;;if (empty($ivar1))&#123; echo &apos;$ivar1&apos; . &quot; 为空或为 0。&quot; . PHP_EOL;&#125;else&#123; echo &apos;$ivar1&apos; . &quot; 不为空或不为 0。&quot; . PHP_EOL;&#125;if (empty($istr1))&#123; echo &apos;$istr1&apos; . &quot; 为空或为 0。&quot; . PHP_EOL;&#125;else&#123; echo &apos;$istr1&apos; . &quot; 字符串不为空或不为0。&quot; . PHP_EOL;&#125;?&gt; 执行结果如下所示：$ivar1 为空或为 0。 $istr1 字符串不为空或不为0。 读取文件，得到状态码12345if(file_exists("/absolution path"))&#123; $res = file_get_contents("/absolution path"); if("0" != $res)&#123; &#125;&#125; 判断字符串a是否存在某字符串bstrpos 会返回0即从a的第一个位置就找到了b12if(false !== strpos("a", "b"))&#123;&#125; 用strlen来替代empty当form var填入0的时候, empty($_POST[‘var’]) empty 为空 “” (空字符串) 0 (作为整数的0) 0.0 (作为浮点数的0) “0” (作为字符串的0) NULL FALSE array() (一个空数组) $var; (一个声明了，但是没有值的变量) empty() 并不会产生警告，哪怕变量并不存在。 这意味着 empty() 本质上与 !isset($var) || $var == false 等价。 empty(trim($name)) is wrong, empty cant contain func but a variable before version 5.3 产生随机数做id12345678if (function_exists('mcrypt_create_iv')) &#123; $_SESSION['token'] = bin2hex(mcrypt_create_iv(32, MCRYPT_DEV_URANDOM));&#125; else &#123; $_SESSION['token'] = bin2hex(openssl_random_pseudo_bytes(32));&#125;md5(uniqid()) replace string or charactersstrtr sql special characters % and _ 1strtr($string, array('_'=&gt;'\_', '%'=&gt;'\%')); the list of php extension php -m php -i php -r “print_r(get_loaded_extensions());” php 7 change log openssl built in (not need install) bcmath built in (in archlinux) php Daily Discoveryphp gengerate pie or line or column image pChart 根据字节数计算单位12345678private function formatBytes($size)&#123; $units = array(&apos;&apos;,&apos;K&apos;,&apos;M&apos;,&apos;G&apos;,&apos;T&apos;); $i = 0; for( ; $size&gt;=1024 &amp;&amp; $i&lt;count($units); $i++)&#123; $size /= 1024; &#125; return round($size,2).$units[$i];&#125; calculated the disk space12disk_total_space()disk_free_space()]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>cookbook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP download]]></title>
    <url>%2Fphp%2Fphp_download.html</url>
    <content type="text"><![CDATA[php downloadphp download big file12345678910111213141516171819if (file_exists($path)) &#123; $file_size = filesize($path); if (FALSE!== ($handler = fopen($path, &apos;r&apos;)))&#123; header(&apos;Content-Description: File Transfer&apos;); header(&apos;Content-Type: application/octet-stream&apos;); header(&apos;Accept-Ranges: bytes&apos;); header(&apos;Content-Disposition: attachment; filename=&apos;.basename($path)); header(&apos;Accept-Length:&apos;. $file_size); header(&apos;Content-Transfer-Encoding: chunked&apos;); header(&apos;Expires: 0&apos;); header(&apos;Cache-Control: must-revalidate, post-check=0, pre-check=0&apos;); header(&apos;Pragma: public&apos;); $buffer_size = 4096*20; while(!feof($handler))&#123; $chunk = fread($handler,$buffer_size); echo $chunk; &#125; fclose($handler); &#125; php upload big file第一步： Apache环境中的档案上传大小控制修改httpd.conf添加下面内容LimitRequestBody 10485760即10M=1010241024，有的文章中提到应改为 600000000重新启动apache，就可以在设置里看到你要的大小 第二步：修改在php5下POST文件大小的限制修改php.ini找到 File Uploadsh区域修改以下几个参数： file_uploads = on ;是否允许通过HTTP上传文件的开关。默认为ON即是开 upload_tmp_dir ;文件上传至服务器上存储临时文件的地方，如果没指定就会用系统默认的临时文件夹(moodle可以不改)upload_max_filesize = 8m ;允许上传文件大小的最大值.找到 Data Handling区域，修改 post_max_size = 8m ;指通过表单POST给PHP的所能接收的最大值，包括表单里的所有值。默认为8M设上述四个参数后，上传小于8M的文件一般不成问题。但如果上传大于8M的文件，只还得设置以下参数：在Resource Limits 区域: max_execution_time = 600 ;每个PHP页面运行的最大时间值(秒)，默认30秒 max_input_time = 600 ;每个PHP页面接收数据所需的最大时间，默认60秒 memory_limit = 8m ;每个PHP页面所吃掉的最大内存，默认8M]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[build php extension fail phpizse]]></title>
    <url>%2Fphp%2Fconfigure%2Fphp_extension_compile_fail.html</url>
    <content type="text"><![CDATA[CDPATH command not found12345678$ make /home/user/libtool: line 482: CDPATH: command not foundlibtool: Version mismatch error. This is libtool 2.4.2, but thelibtool: definition of this LT_INIT comes from an older release.libtool: You should recreate aclocal.m4 with macros from libtool 2.4.2libtool: and run autoconf again.make: *** [xdebug.lo] Error 63 solution aclocal libtoolize –force autoheader autoconf solution2 rm –rf aclocal.m4 autoreconf solution312345678If you have error with libtool version after make - way to install:phpize --clean &amp;&amp; phpizerm aclocal.m4aclocalautoconf./configuremakemake install]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>configure</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wine setting]]></title>
    <url>%2Fubuntu%2Fdeepin-wine.html</url>
    <content type="text"><![CDATA[软件文字显示方块（如企业微信） 去windows 系统 上去复制一份Fonts字体 复制到你要修复的wine容器 将字体放入~/.wine/drive_c/windows/Fonts 里面，如果是deepin的话，就放在~/.deepinwine/XXX/drive_c/windows/Fonts里面（XXX指deepin下的你安装的程序） touch zh.reg 1234567891011REGEDIT4[HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\FontLink\SystemLink]&quot;Lucida Sans Unicode&quot;=&quot;msyh.ttc&quot;&quot;Microsoft Sans Serif&quot;=&quot;msyh.ttc&quot;&quot;MS Sans Serif&quot;=&quot;msyh.ttc&quot;&quot;Tahoma&quot;=&quot;msyh.ttc&quot;&quot;Tahoma Bold&quot;=&quot;msyhbd.ttc&quot;&quot;msyh&quot;=&quot;msyh.ttc&quot;&quot;Arial&quot;=&quot;msyh.ttc&quot;&quot;Arial Black&quot;=&quot;msyh.ttc&quot; WINEPREFIX=~/.deepinwine/Deepin-WXWork /usr/bin/deepin-wine regedit zh.reg]]></content>
      <categories>
        <category>wine</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>wine</tag>
        <tag>deep-win</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim configure]]></title>
    <url>%2Fvim%2Fconfigure.html</url>
    <content type="text"><![CDATA[YouCompleteMe unavailable No module named future cd bundle/YouCompleteMe git submodule update --init --recursive if error, git config –global YouCompleteMe cregex does not appear to contain CMakeLists.txt 由于cregex路径里面为空 git remote -v 获取git 路径 git clone 路径 将其文件夹命名为cregex vim automatic construction tools k-vim k-vim github]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>configure</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2Fgit%2Fconfigure.html</url>
    <content type="text"><![CDATA[查看git的远端路径git remote -v 查看从哪个分支拉下了的git remote show origin]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>configure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache cookbook]]></title>
    <url>%2Fapache%2Fphp_My_cookbook.html</url>
    <content type="text"><![CDATA[apache cookbookquery apache default user or group ps aux | egrep ‘(apache|httpd)’ ca认证的时候有时候出现了403首先需要开启apahce ssl trace 3级别的日志,配置1234&lt;IfModule mod_ssl.c&gt; ErrorLog /var/log/apache2/ssl_engine.log LogLevel trace3&lt;/IfModule&gt; apache重启 然后去复现bug的过程，查看/var/log/apache2/ssl_engine.log日志，见图ssl error 发现正常认证过程是full renegotiation 而错误的认证过程是 quick renegotiation。quick renegotiation会导致认证过程找到不到peer chain 导致认证失败 返回403。 https://bz.apache.org/bugzilla/show_bug.cgi?id=55786 在apache官方bugzilla查看 这个bug在version 2.4.24 已经修复了，但是我们的设备是2.4.16，所以解决办法是： a) Removing “OptRenegotiate” on /cert/. We need this feature to prevent client certificate requests with every access to /cert b) Setting SSLVerifyClient to require or optional on the whole virtual host: Not possible because requests to /nocert should not trigger a certificate request. c) Disable keep-alive. 因此，我关闭了OptRenegotiate 优化Renegotiate过程，让每次Renegotiate都是full的状态，这样改会降低一点速度，如果需要优化版本只能升级apahce到2.4.24以上]]></content>
      <categories>
        <category>apache</category>
      </categories>
      <tags>
        <tag>apache</tag>
        <tag>setting</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[use this]]></title>
    <url>%2Fjs%2Fuse_this.html</url>
    <content type="text"><![CDATA[input onclick use this1234567//注意this后面不能加空格&lt;input onclick="return enable_box(this,'test')" /&gt;//形参不能写thisfunction enable_box(obj, url) &#123; console.log(obj);&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jq from label name get]]></title>
    <url>%2Fjs%2Fjquery%2Fjq_get_name.html</url>
    <content type="text"><![CDATA[jquery from label name get label12345678910jQuery("input[name='imgtitle']").each(function()&#123; titles += jQuery(this).val()+",";&#125;);var check_val = [];jQuery("input[name='checkbox']").each(function()&#123; if(jQuery(this).prop("checked")) check_val.push(jQuery(this).val());&#125;);]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Add app to ubuntu dash]]></title>
    <url>%2Fubuntu%2FaddAppTOdash.html</url>
    <content type="text"><![CDATA[Add app to ubuntu dash在/usr/share/applications/目录下新建一个名为eclipse.desktop的文件。文件内容如下：123456789[Desktop Entry]Version=2018.09Name=EclipseGenericName[zh_CN]=EclipseExec=/home/user/programs/eclipse/eclipseTerminal=falseIcon=/home/user/programs/eclipse/icon.xpmType=ApplicationCategories=Development 其中Exec=/home/yueru/programs/eclipse/eclipse对应eclipse启动文件的位置。（Eclipse安装包解压在/home/yueru/programs/eclipse） 然后你就可以发现启动器中存在Eclipse了。]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu best tool]]></title>
    <url>%2Fubuntu%2Fbest_tool.html</url>
    <content type="text"><![CDATA[十大好用的Linux实用工具推荐，亲测！本文我们收集了对Linux用户非常有用的10个工具，其中包括网络监控、系统审计或其它有用命令，这10个Linux工具可以帮助大家提高工作和使用效率，非常实用。 1.w 对，你没看错，就是 w 命令。使用该命令我们可以查看到当前登录系统的用户是谁，以及执行了哪些命令。 2.nmon Nmon 是一个可以监控当前系统性能的小工具，使用之前需要先用如下命令进行安装： sudo apt-get install nmon 安装好后执行 nmon 命令即可打开： nmon nmon 可以查看网络、CPU、内存和磁盘的使用情况。 打开之后按 c 查看 CPU 信息： 打开之后按 n 查看网络信息： 3.ncdu ncdu 命令可以用来查看和分析 Linux 中各目录对磁盘空间占用情况的工具，请使用如下命令进行安装： apt-get install ncdu 安装好后执行如下命令即可从根目录开始分析： ncdu / 注意：执行上述命令会占用大量磁盘 I/O 分析完成后，会生成类似如下截图的输出： 我们可以在结果界面按 n 按名称进行排序或按 s 按大小进行排序。 4.slurm slurm 是一个网卡带宽监控命令行实用程序，它会自动生成 ASCII 图形输出。使用之前先用如下命令进行安装： apt-get install slurm 使用如下命令进行输出： slurm -i &lt;网卡名称&gt; slurm 界面中可以执行如下选项： ◆I：显示lx/tx状态 ◆c：切换到经典界面 ◆r：手动刷新界面 ◆q：退出工具 5.findmnt Findmnt 是一个 Linux 内置的命令行工具，它主要用于查找挂载的文件系统状态。Findmnt 可以查看到当前系统中已挂载的设备，在必要时还可进行 mount 或 unmount 操作。 执行 findmnt 命令后会看到如下输入： 当然，还有如下参数可用： ◆findmnt -l ：以列表方式进行输出 ◆findmnt -s ：输出 fstab 中挂载的设备 ◆findmnt -t ext4 ：按文件系统类型进行输出 6.dstat dstat 是一个可以非常灵活使用和进行组合使用的工具，它可用于监控内存、进行、网络及磁盘性能，可用于替代 ifstat、iostat、dmstat等工具。使用之前需先执行如下命令进行安装： apt-get install dstat 执行如下命令可以看到所有监控数据： dstat 其可选参数非常多，常用的有： ◆dstat -c ： 监控CPU ◆dstat -cdl -D sda1 ：监控CPU详细信息 ◆dstat -d ：监控磁盘 7.saidar saidar 是另一个 CLI 系统数据监控和统计工具，可提供有关磁盘、网络、存储和 SWAP 的监控信息。使用之前需先使用如下命令进行安装： sudo apt-get install saidar 安装完成后可直接执行 saidar 进行输出，但我们通常使用带参数的命令生成带颜色输出： saidar -c 8.ss ss 全称 socket statistics，是一个可以替代 netstat 的网络连接查看工具。 直接执行 ss 即可进行查看： 常用参数有： ss -A tcp ：指定查看协议 ss -ltp ：显示进程名称和 PID 9.ccze ccze 非常有用，它可以用不同颜色高亮日志，协助管理员进行区分和查看分析。使用之前需先使用如下命令进行安装： apt-get install ccze 我们可以使用类似如下方式进行使用： tailf /var/log/syslog | ccze 而使用 ccze -l 参数可以查看其支持的日志类型。 10.ranwhen.py 我们最后介绍的 ranwhen.py 是一个 python 工具，它可以以图形方式显示系统活动。 要使用该工具需要先安装 python 语言支持： sudo apt-add-repository ppa:fkrull/deadsnakes sudo apt-get update sudo apt-get install python3.2 然后下载ranwhen.py wget https://github.com/p-e-w/ranwhen/archive/master.zip unzip master.zip &amp;&amp; cd ranwhen-master 使用如下命令即可执行ranwhen.py python3.2 ranwhen.py]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[adaptively set iframe height after iframe onloaded]]></title>
    <url>%2Fjs%2Fself_adaption_set_iframe_height.html</url>
    <content type="text"><![CDATA[adaptively set iframe height after iframe onloaded1234567891011121314151617181920212223242526function setIframeHeight(iframe) &#123; if (iframe) &#123; var iframeWin = iframe.contentWindow || iframe.contentDocument.parentWindow; if (iframeWin.document.body) &#123; iframe.height = iframeWin.document.documentElement.scrollHeight || iframeWin.document.body.scrollHeight; &#125; &#125;&#125;function getIframeHeight(iframe)&#123; var iframeWin = iframe.contentWindow || iframe.contentDocument.parentWindow; var height = iframeWin.document.documentElement.scrollHeight || iframeWin.document.body.scrollHeight; return height&#125;// use tim to set iframe height after iframe onloadedjQuery(document.getElementById('iframe_id')).load(function()&#123; var iframe = document.getElementById('iframe_id'); var height = getIframeHeight(iframe); var tim = setInterval(function()&#123; setIframeHeight(iframe); var after_height = getIframeHeight(iframe); if(after_height &gt; height)&#123; window.clearInterval(tim); &#125; &#125;,100)&#125;);]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[how to show zero value in bar]]></title>
    <url>%2Fhighchart%2Fhighchart_bar_show_zero_value.html</url>
    <content type="text"><![CDATA[how to show zero value in bar12345plotOptions: &#123; column: &#123; minPointLength: 3 &#125;&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>highchart</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[table border collapse]]></title>
    <url>%2Fcss%2Ftabel_border_collapse.html</url>
    <content type="text"><![CDATA[the table border is displayed as a separate borderto achieve the effect of td or th border covering the outer border of the table 12345678910table &#123; border-collapse:collapse; border:2px solid red; &#125;table, td, th &#123; border-bottom:2px solid black; &#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[checkbox as radio input]]></title>
    <url>%2Fjs%2Fcheckbox_as_radio.html</url>
    <content type="text"><![CDATA[checkbox as radio input将checkbox 作为 单选框来使用 1&lt;input style="vertical-align: middle;" id="Checkbox" type="checkbox" name="switch" &lt;?=$isChecked?&gt; /&gt;&lt;span&gt;启用&lt;/span&gt; 1234//当form表单提交的时候执行该语句var enable_use = document.getElementById("Checkbox").checked;var val = (enable_use == true)?'true':'false';document.getElementById("Checkbox").value = val; 12345if(!empty($switch))&#123; $this-&gt;updateJMREnable($switch);&#125;else&#123; $this-&gt;updateJMREnable("false");&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[get string actual length include Chinese]]></title>
    <url>%2Fjs%2Fget_actual_char_length.html</url>
    <content type="text"><![CDATA[get string actual length include Chinese1234//先把中文替换成一个字节的英文，在计算长度function getCharLength(str)&#123; return str.replace(/[\u0391-\uFFE5]/g,"a").length;&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jq from label name get]]></title>
    <url>%2Fjs%2Fjquery%2Fjq_select.html</url>
    <content type="text"><![CDATA[select in jquery增加删除select里面的option1234567$("#select_id").append("&lt;option value='Value'&gt;Text&lt;/option&gt;"); //为Select追加一个Option(下拉项) $("#select_id").prepend("&lt;option value='0'&gt;请选择&lt;/option&gt;"); //为Select插入一个Option(第一个位置) $("#select_id option:last").remove(); //删除Select中索引值最大Option(最后一个) $("#select_id option[index='0']").remove(); //删除Select中索引值为0的Option(第一个) $("#select_id option[value='3']").remove(); //删除Select中Value='3'的Option $("#select_id option[text='4']").remove(); //删除Select中Text='4'的Option jQuery("#link3").find("option").remove();//删除select里面所有的option 获取select里面的值12345$("#select_id").change(function()&#123;//code...&#125;); //为Select添加事件，当选择其中一项时触发 var checkText=$("#select_id").find("option:selected").text(); //获取Select选择的Text var checkValue=$("#select_id").val(); //获取Select选择的Value var checkIndex=$("#select_id ").get(0).selectedIndex; //获取Select选择的索引值 var maxIndex=$("#select_id option:last").attr("index"); //获取Select最大的索引值 select 事件 onchange 选择option触发的事件 onfocus 点击下拉框，就会触发的事件 onclick 不会触发任何事件]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sudo no password]]></title>
    <url>%2Fubuntu%2Fsudo_nopasswd.html</url>
    <content type="text"><![CDATA[setting sudo no password通过修改sudouser列表的方式免密码 首先切换到root用户下 sudo -i,这个时候需要输入一次用户名和密码。 然后，执行visudo，在打开的文件中找到root ALL=(ALL) ALL 在其下面追加如下配置，即执行所有超级用户命令密码。 your_user_name ALL=(ALL) NOPASSWD: ALL]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>setting</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[backup ubuntu system]]></title>
    <url>%2Fubuntu%2Frestore_ubuntu_system.html</url>
    <content type="text"><![CDATA[原链接：https://community.bwbot.org/topic/167 Systemback是一个Ubuntu系统中用于发布自定义系统镜像和系统备份的软件。有时候我们对自己的Ubuntu做了很多设置，比如各种软件包，各种自定义的配置。我们想要在另一台电脑上也安装一个和我们一模一样的系统，这个时候就会用到这种方法了。这个方法不仅可以用于发布系统，也可以用来作为系统备份使用。 下面就具体介绍一下这个软件的安装和使用方法 安装sudo add-apt-repository ppa:nemh/systemback sudo apt-get update &amp;&amp; sudo apt-get install systemback unionfs-fuse 使用方法安装完成后在Dash菜单中就能找到这个软件了 输入管理员密码，打开后界面如下图所示 如果我们需要创建系统备份，点击Create new 就可以了。下面介绍一下自定义系统的iso文件如何制作。1. 点击右侧的Live system create按钮，出现界面如下图所示2. 勾选左侧的include the user data files，这样自己主文件夹内的文件都会被包含在系统镜像中。很多相关的程序的配置文件都是保存在主文件夹内的。Working Directory是设置工作目录，程序运行时产生的临时文件都会被保存在这里。所以一定要保证这里有足够的存储空间。3. 点击Create New按钮就开始创建了，等待创建完成。完成后界面如下图所示右侧的列表中就是已经创建的备份。我已经创建了两个相关的备份，所以有两个在右侧显示。此时文件没有转换成iso格式，选中你要转换的备份，点击convert to ISO 就可以开始转换了。转换完成后，在你的工作目录下就能找到生成的iso文件。 这个文件就可以用来安装系统了。同时还可以作为live系统来使用。 在备份过程中可能提示 The restore point creation is aborted! There has been critical changes in the file system during this operation 这并不一定是由于系统发生了严重的更改，只要是在复制文件的过程中出现错误都会出现这个信息。详细的错误信息可以通过 systemback-sustart 这个指令去调试，看看具体哪一个文件复制出了问题。极有可能的是权限问题。也可以通过这个指令去调试 DBGLEV=3 systemback-sustart 当错误出现后会在/tmp文件夹下创建一个systemback的错误信息文件。可以方便的通过这个文件去找到错误的原因。]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>backup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zsh setting]]></title>
    <url>%2Fubuntu%2Fzsh_setting.html</url>
    <content type="text"><![CDATA[How to fix and recover a “corrupt history file” in zshSimply removing random characters may also work: 12vim .zsh_historyRemove any strange characters, which would most probably be near the end. (In my case I had a string of @ in the second last line, following a forced shutdown) seting ls file color12vim .zshrcexport CLICOLOR=1]]></content>
      <categories>
        <category>zsh</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo head setting]]></title>
    <url>%2Fhexo%2Fhexo_post_header.html</url>
    <content type="text"><![CDATA[hexo post文件头设置12345678910---title: Hexo head settingcategories: hexocopyright: truetags: - hexo - settingkeywords:description:--- hexo abstract setting12abstract content&lt;!--more--&gt; multi level categories12345categories: [no 1 categories, no 2 categories]categories: - no 1 - no 2]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>setting</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP deal with ip and mask]]></title>
    <url>%2Fphp%2Fphp_deal_ip_and_mask.html</url>
    <content type="text"><![CDATA[PHP deal with ip and mask12345678910111213141516171819202122function ip_parse($ip_str) &#123; $mark_len = 32; if (strpos($ip_str, "/") &gt; 0) &#123; list($ip_str, $mark_len) = explode("/", $ip_str); &#125; $ip = ip2long($ip_str); $mark = 0xFFFFFFFF &lt;&lt; (32 - $mark_len) &amp; 0xFFFFFFFF; $ip_start = $ip &amp; $mark; $ip_end = $ip | (~$mark) &amp; 0xFFFFFFFF; return array($ip, $mark, $ip_start, $ip_end);&#125;list($ip, $mark, $ip_start, $ip_end) = ip_parse("192.168.1.12/24");echo "IP地址 : ", long2ip($ip), "\n";echo "子网掩码: ", long2ip($mark), "\n";echo "IP段开始: ", long2ip($ip_start), "\n";echo "IP段结束: ", long2ip($ip_end), "\n";IP地址 : 192.168.1.12子网掩码: 255.255.255.0IP段开始: 192.168.1.0IP段结束: 192.168.1.255 its in ip segment1234567891011function ip_in($ip, $ip_str) &#123; $mark_len = 32; if (strpos($ip_str, "/") &gt; 0) &#123; list($ip_str, $mark_len) = explode("/", $ip_str); &#125; $right_len = 32 - $mark_len; return ip2long($ip) &gt;&gt; $right_len == ip2long($ip_str) &gt;&gt; $right_len;&#125;var_dump(ip_in("192.168.1.1", "192.168.1.0/24"));]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>ip</tag>
        <tag>ipmask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP delete array element删除数组元素]]></title>
    <url>%2Fphp%2Fphp_delete_array_element.html</url>
    <content type="text"><![CDATA[PHP删除数组元素unset from key1234unset($array['key'])//将数组的引索重新排列array_values($array) array_search from value12345$arr1 = array(1,3, 5,7,8);$key = array_search(3, $arr1);if ($key !== false) array_splice($arr1, $key, 1);// 引索会自动排列var_dump($arr1); array_splice123$array = array(0 =&gt; "a", 1 =&gt; "b", 2 =&gt; "c");// 引索不会保存array_splice($array, 1, 1); array_diff123$array = array(0 =&gt; "a", 1 =&gt; "b", 2 =&gt; "c");// 引索会保存$array = array_diff($array, ["a", "c"]); array_diff_key按键删除多个元素123$array = array(0 =&gt; "a", 1 =&gt; "b", 2 =&gt; "c");// 引索会保存$array = array_diff_key($array, [0 =&gt; "xy", "2" =&gt; "xy"]);]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP quotes]]></title>
    <url>%2Fphp%2Fphp_quotes.html</url>
    <content type="text"><![CDATA[php quote魔术引号若是打开的话，所有的反斜线（\）、单引号（’）、双引号（”）、NULL 字符都会被自动加上一个反斜线进行转义，这和 addslashes() 作用完全相同 相关的函数 set_magic_quotes_runtime magic_quotes_gpc addslashes stripslashes set_magic_quotes_runtime()设置当前magic_quotes_runtime 配置选项的激活状态，0为关闭，1为开启。set_magic_quotes_runtime(1)或是配置文件中magic_quotes_runtime为true（这个在php.ini中配置），那么php脚本读取文件或是从数据库中读取数据，遇到反斜线（\）、单引号（’）、双引号（”）、NULL时，会在前面自动加上转义字符，变成\、\’、\”、\NULL；若是关闭的话，也就是set_magic_quotes_runtime(0)magic_quotes_runtime为false，那么便会转义，此时可以借助addslashes进行转义。 magic_quotes_gpc()当此值为1时，会对HTTP请求中的G（$_GET）、P（$_POST）、C（$_COOKIE）单双引号和反斜线进行转义；反之则不会。该操作一般见于表单提交的数据库操作，若是值为0时，便用addslashes进行转义存入数据库中，取出时再用stripslashes函数把反斜线给去掉。 特别注意的是在PHP 5.4版本时，魔术引号被移除了，因此转义都需要加上addslashes函数。 12345678910$_GET['des'] = "she's a beauty";foreach (array('_GET', '_POST', '_COOKIE') as $_request)&#123; echo $_request; // _GET_POST _COOKIE foreach ($$_request as $_key=&gt; $_value)&#123; // $_key为键，如_GET，$$_key为$_GET // $$_key=$_value意思就是把$_GET['des'] = 1111便为$des=she\'s a beauty $_key&#123;0&#125; != '_' &amp;&amp; $$_key=addslashes($_value); echo $$_key; &#125;&#125; 12345if(get_magic_quotes_gpc() &amp;&amp; (! ini_get('magic_quotes_sybase')))&#123; $value = stripslashes($_GET['value']);&#125;else&#123; $value = $_GET['value'];&#125;]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP Filesystem]]></title>
    <url>%2Fphp%2Fphp_get_path_filename.html</url>
    <content type="text"><![CDATA[PHP Filesystem 函数 描述 PHP basename() 返回路径中的文件名部分。 3 chgrp() 改变文件组。 3 chmod() 改变文件模式。 3 chown() 改变文件所有者。 3 clearstatcache() 清除文件状态缓存。 3 copy() 复制文件。 3 delete() 参见 unlink() 或 unset()。 dirname() 返回路径中的目录名称部分。 3 disk_free_space() 返回目录的可用空间。 4 disk_total_space() 返回一个目录的磁盘总容量。 4 diskfreespace() disk_free_space() 的别名。 3 fclose() 关闭打开的文件。 3 feof() 测试文件指针是否到了文件结束的位置。 3 fflush() 向打开的文件输出缓冲内容。 4 fgetc() 从打开的文件中返回字符。 3 fgetcsv() 从打开的文件中解析一行，校验 CSV 字段。 3 fgets() 从打开的文件中返回一行。 3 fgetss() 从打开的文件中读取一行并过滤掉 HTML 和 PHP 标记。 3 file() 把文件读入一个数组中。 3 file_exists() 检查文件或目录是否存在。 3 file_get_contents() 将文件读入字符串。 4 file_put_contents() 将字符串写入文件。 5 fileatime() 返回文件的上次访问时间。 3 filectime() 返回文件的上次改变时间。 3 filegroup() 返回文件的组 ID。 3 fileinode() 返回文件的 inode 编号。 3 filemtime() 返回文件的上次修改时间。 3 fileowner() 文件的 user ID （所有者）。 3 fileperms() 返回文件的权限。 3 filesize() 返回文件大小。 3 filetype() 返回文件类型。 3 flock() 锁定或释放文件。 3 fnmatch() 根据指定的模式来匹配文件名或字符串。 4 fopen() 打开一个文件或 URL。 3 fpassthru() 从打开的文件中读数据，直到 EOF，并向输出缓冲写结果。 3 fputcsv() 将行格式化为 CSV 并写入一个打开的文件中。 5 fputs() fwrite() 的别名。 3 fread() 读取打开的文件。 3 fscanf() 根据指定的格式对输入进行解析。 4 fseek() 在打开的文件中定位。 3 fstat() 返回关于一个打开的文件的信息。 4 ftell() 返回文件指针的读/写位置 3 ftruncate() 将文件截断到指定的长度。 4 fwrite() 写入文件。 3 glob() 返回一个包含匹配指定模式的文件名/目录的数组。 4 is_dir() 判断指定的文件名是否是一个目录。 3 is_executable() 判断文件是否可执行。 3 is_file() 判断指定文件是否为常规的文件。 3 is_link() 判断指定的文件是否是连接。 3 is_readable() 判断文件是否可读。 3 is_uploaded_file() 判断文件是否是通过 HTTP POST 上传的。 3 is_writable() 判断文件是否可写。 4 is_writeable() is_writable() 的别名。 3 link() 创建一个硬连接。 3 linkinfo() 返回有关一个硬连接的信息。 3 lstat() 返回关于文件或符号连接的信息。 3 mkdir() 创建目录。 3 move_uploaded_file() 将上传的文件移动到新位置。 4 parse_ini_file() 解析一个配置文件。 4 pathinfo() 返回关于文件路径的信息。 4 pclose() 关闭有 popen() 打开的进程。 3 popen() 打开一个进程。 3 readfile() 读取一个文件，并输出到输出缓冲。 3 readlink() 返回符号连接的目标。 3 realpath() 返回绝对路径名。 4 rename() 重名名文件或目录。 3 rewind() 倒回文件指针的位置。 3 rmdir() 删除空的目录。 3 set_file_buffer() 设置已打开文件的缓冲大小。 3 stat() 返回关于文件的信息。 3 symlink() 创建符号连接。 3 tempnam() 创建唯一的临时文件。 3 tmpfile() 建立临时文件。 3 touch() 设置文件的访问和修改时间。 3 umask() 改变文件的文件权限。 3 unlink() 删除文件。 3 compatibility当在 Unix 平台上规定路径时，正斜杠 (/) 用作目录分隔符。而在 Windows 平台上，正斜杠 (/) 和反斜杠 () 均可使用。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>os</tag>
        <tag>filesystem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP filter func]]></title>
    <url>%2Fphp%2Fphp_filter_fuc.html</url>
    <content type="text"><![CDATA[php filter function filter_has_var() 检查是否存在指定输入类型的变量 filter_id() 返回指定过滤器的 ID 号。 filter_input() 从脚本外部获取输入，并进行过滤。 filter_input_array() 从脚本外部获取多项输入，并进行过滤。 filter_list() 返回包含所有得到支持的过滤器的一个数组。 filter_var_array() 获取多个变量，并进行过滤。 filter_var() 获取一个变量，并进行过滤。 type INPUT_GET INPUT_POST INPUT_COOKIE INPUT_SERVER INPUT_ENV INPUT_SERVER INPUT_SESSION INPUT_REQUEST filter FILTER_CALLBACK 调用用户自定义函数来过滤数据。 FILTER_SANITIZE_STRING 去除标签，去除或编码特殊字符。 FILTER_SANITIZE_STRIPPED “string” 过滤器的别名。 FILTER_SANITIZE_ENCODED URL-encode 字符串，去除或编码特殊字符。 FILTER_SANITIZE_SPECIAL_CHARS HTML 转义字符 ‘“&lt;&gt;&amp; 以及 ASCII 值小于 32 的字符。 FILTER_SANITIZE_EMAIL 删除所有字符，除了字母、数字以及 !#$%&amp;’*+-/=?^_`{|}~@.[] FILTER_SANITIZE_URL 删除所有字符，除了字母、数字以及 $-_.+!*’(),{}|\^~[]`&lt;&gt;#%”;/?:@&amp;= FILTER_SANITIZE_NUMBER_INT 删除所有字符，除了数字和 +- FILTER_SANITIZE_NUMBER_FLOAT 删除所有字符，除了数字、+- 以及 .,eE FILTER_SANITIZE_MAGIC_QUOTES 应用 addslashes()。 FILTER_UNSAFE_RAW 不进行任何过滤，去除或编码特殊字符。 FILTER_VALIDATE_INT 把值作为整数来验证。 FILTER_VALIDATE_BOOLEAN 把值作为布尔选项来验证。如果是 “1”、”true”、”on” 和 “yes”，则返回 TRUE。如果是 “0”、”false”、”off”、”no” 和 “”，则返回 FALSE。否则返回 NULL。 FILTER_VALIDATE_FLOAT 把值作为浮点数来验证。 FILTER_VALIDATE_REGEXP 根据 regexp（一种兼容 Perl 的正则表达式）来验证值。 FILTER_VALIDATE_URL 把值作为 URL 来验证。 FILTER_VALIDATE_EMAIL 把值作为 e-mail 地址来验证。 FILTER_VALIDATE_IP 把值作为 IP 地址来验证，只限 IPv4 或 IPv6 或 不是来自私有或者保留的范围。 reference参考]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[onclick lanuch a post request，解决get参数太长，导致请求失败]]></title>
    <url>%2Fjs%2Fonclick_for_post.html</url>
    <content type="text"><![CDATA[onclick lanuch post request有时候，由于get请求下载文件，请求参数超过了2048字符，在IE等浏览器就会导致参数不完整 因此使用post请求，其参数就没有限制长度， 然后，使用ajax发起post请求，无法触发文件下载，因此使用模拟form表单发起post请求 原生onclick 发起post请求 12345678910111213141516function onclickpost(URL, PARAMS) &#123; var temp = document.createElement("form"); temp.action = URL; temp.method = "post"; temp.style.display = "none"; for (var x in PARAMS) &#123; var opt = document.createElement("textarea"); opt.name = x; opt.value = PARAMS[x]; temp.appendChild(opt); &#125; document.body.appendChild(temp); temp.submit(); temp.parentNode.removeChild(temp);&#125;onclickpost(url, &#123;cat:rawinfo&#125;)]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cmder 各类配置以及问题解决]]></title>
    <url>%2Fcmder%2Fcmder.html</url>
    <content type="text"><![CDATA[cmder 配置cmder 显示 oh my zsh会出现乱码 去网站nerdfonts最下面下载hack字体，解压安装hack字体 在cmder 的setting中 font是 选择hack字体 启动quake模式，使得cmder能够从window最上面一键呼出 cmder的setting，general 的quake style，勾选 quake style slide down , always on top , restore inactive .. , restore to active monitor setting的 keys &amp;macro 修改 minimize/restore quake style hotkey 快捷键]]></content>
      <categories>
        <category>cmder</category>
      </categories>
      <tags>
        <tag>cmder</tag>
        <tag>oh my zsh</tag>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim]]></title>
    <url>%2Fvim%2Fvim.html</url>
    <content type="text"><![CDATA[vim 不按 Esc 而是按 ^『或者 ^c，速度快很多 学会几个定位键的区别：0, $, {, }, g, G, w, e, b… Shift+V 选定几行，然后用 一起移动 Ctrl+V 选定行首或行尾的字符，然后用 shift+i 做插入，或者 shift+x 做删除 学会用 y,d 和 p, P 做粘贴剪切 学会用 ^W 的窗口操作。打开文件用 sp 或者 vs 学会记录宏的命令。用 q 加任意键开始录制，再按 q 保存。然后可用 @加这个任意键回放，在 @前加数字可定义回放次数 “.”重复上一个命令，”u”取消上一个命令，”^r”反取消 ^n, ^p 用 buf 里的关键词补全。 学会搜索替换”:%s/ 要搜的东西 / 要换成的东西 /g” 任何时候移到一个单词上按#的话可以高亮这个文档里所有一样的单词 用“/”做搜索，按 n 或 N 上一个 / 下一个 “:! 命令 &amp;”可直接运行这个命令，用”:! 命令 %&amp;”如果你想让这个命令对当前所编辑文件做操作。 任何时候可用”:cd %:p:h”来切换目录到当前编辑文件所在目录。 “.” 这个 mark 代表最后一次修改的地方，所以 “‘.” 可以跳到最后一次修改的地方，’. 可以跳到最后一次修改的那一行。 g; 和 g, 则可以在整个 changelist 里面来回跳转，敲 :help changelist 可以看说明。 + or or //change windows size + left or right //rapidly change windows to watch two files diffience + &lt;+&gt; or //change windows size vim -on file1 file2 … // n split windows numbers o horizontal split O vertical split :sp filename //horizontal split windows ^M how to delete ^M :%s/^M//g ^M “ +“ run markdown rmk open by typora show all result when search /searchStringlv move windows center to cursor zz z+ z- H M L move cursor to windows :set scrolloff=10 //let cursor on windows center alwaysly move on buffers :ls, :buffers show all buffers :bn[ext] next buffer :bp[revious] last buffer :b2 move to number 2 buffer :b exa move to match exa file such as example.txt :sb 3 split windows open buffer number 3 file by horizontal spl :vertical sb 3 by vertical split reg pasteclipboard :reg show all reg “+ system reg yyn n is name of reg paste reg content to current lin on txt file move to title ctrl + ] 2017/2/26 星期日 21:05:31switch tabel gt create tabel nt insert current time tt switch windows Ctrl + f : next windows Ctrl + b : last windows ctrl + d : next half windows ctrl + u : last half windows delete trick dw de db d$ delete to row end di dtc delete between c all charcters read and save :r filename read filename to current cursor 1,20 w filename create new filename to 1,20 line content 1,$ w filename whole content write new filename 1,20 w &gt;&gt; filename write 1,20 content to filename last line autoindent == jump to last cursor ctrl + i ctrl + o jedi K document g go to not for javascript setting pwd . nerdtrem rename file m -&gt;m alter filename delete file use key “m” emmet key ,, == &lt;ctrl y&gt;, go to mark mark place: m {a-zA-Z} go to mark: ‘{a-zA-Z} delete mark: :delmarks {a-zA-Z} show all mark: :marks line choose by visual mode line visual mode: V Vjj 块 visual mode: ctrl + v but on windows ctrl + q gv =&gt; choose last visual chosed text o =&gt; cursor move to selected text end O =&gt; cursor move to selected text start run python code on your vim12s = 'djj'print s Run code by select 2 line Vkk, then press: !python and hit enteroutput:djj anothor example:123def func(x, y): return x + yprint func(3, 4) output:7 12for i in 'moonclearner': print i output:123456789101112moonclearner vim-surround“hello world” press cs”‘ inside “ switch to ‘‘hello world’ press cs’ inside ‘ switch to hello world cst”“hello world” ds” delete “hello world cursor on hello ysiw][hello] world cs]{{ hello } world yssb or yss) wrap entire line({ hello } world) ds{ds) revert to original texthello world ysiw cursor on hellohello world VS wrap hello world close label tag &gt;output: block visual ctrl+v on unix ctrl+q on windows jjj or % muti line select i,I,a,A to input ^ and 01this a sentence! cursor on t ^ the cursor will jump to c 0 the cursor will jump to space, first column $ and g_ $ go to the end of line g_ go to the last non-blank character of line buffer :bn :bp :buffers -&gt; show all buffers saveas :saveas -&gt; save as # and * # look previous same character * jump next same character yank muti times character this my test and test the cursor on i y2/test -&gt;will copy is my test and yank up to the second occurence of test y/test -&gt; will yank is my yank up to the first test before ye y$ f and t fa -&gt; go to next occurence of the letter a on the line , and ; respresent next and previous, reverse use F ta -&gt; go to just before the character a, reverse use Tdt and yt t represent to delete everything util the character before yank everything util the character before Zone select adb(map(+)(“foo”))nnn cursor on o vi” -&gt; will select foo va” -&gt; will select “foo” vi) -&gt; will select “foo” va) -&gt; will select (“foo”) v2i) -&gt; willl select map(+)(&quot;foo&quot;) v2a) -&gt; will select (map(+)(&quot;foo&quot;)) completion ctrl+n next completion ctrl+p previous completion Macros qa record actions in the reg a q stop record actions @a replay the macro saved into the reg a @@ to replay the last executed macro number@@ visual using J -&gt;join all the lines together &lt; or &gt; -&gt;indent to left or right = -&gt;auto indent split :split :vsplitopen nerdtree :Vexplore :Sexplore common command add ; three line at the line ctrl+q -&gt;$ -&gt;jjj -&gt;A -&gt;; -&gt;Esc vim save as sudo :w !sudo tee % :%!sudo bash -c “cat &gt; ‘%’” yapf python format requirement python and pip install yapf = run only read file by user confsudo -E vim filename]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>text</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP dynamically create object]]></title>
    <url>%2Fphp%2Fcookbook%2Fphp_dynamic_create_object.html</url>
    <content type="text"><![CDATA[PHP dynamically create object123$object = new ReflectionClass('PDO');$object-&gt;newInstanceArgs(array('arg1'=&gt;$arg1, 'arg2'=&gt;$arg2)); PHP dynamically calling func1234567$classname = "TestClassName";$object = new #classname();$methodname = "getData";$object-&gt;$methodname("arg1", "arg2");]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP database transaction]]></title>
    <url>%2Fphp%2Fcookbook%2Fphp_database_transaction.html</url>
    <content type="text"><![CDATA[PHP database transaction123456789101112131415161718192021222324252627282930class Message&#123; protected $db; // $form_errors save post validate error for showing error in pages protected $form_errors = array(); public function __construct()&#123; set_exception_handler(array($this, 'logAndDie')); $this-&gt;db = new PDO("sqlite:/tmp/tmp.db"); $this-&gt;db-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); &#125; protected function save()&#123; $this-&gt;db-&gt;beginTransaction(); pass $this-&gt;db-&gt;commit(); &#125; public function valid()&#123; pass &#125; public function logAndDie(Exception $e)&#123; print 'ERROR: '. htmlentities($e-&gt;getMessage()); if($this-&gt;db-&gt;inTransaction())&#123; $this-&gt;db-&gt;rollback(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP PDO error info]]></title>
    <url>%2Fphp%2Fcookbook%2Fphp_pdo_error_info.html</url>
    <content type="text"><![CDATA[PHP PDO catch error info`php try{ $db = new PDO(‘sqlite:/tmp/tmp.db’); $db-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); $st = $db-&gt;prepare(‘SELECT * FROM tmp’); $st-&gt;execute(): while($row = $st-&gt;fetch(PDO:FETCH_NUM)){ print implode(‘,’, $row).”\n”; }}catch(Exception $e){ print “problem: “ . $e-&gt;getMessage();} referencephp cookbook 10.10]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>pdo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP session]]></title>
    <url>%2Fphp%2Fcookbook%2Fphp_session.html</url>
    <content type="text"><![CDATA[PHP SessionPHP redirect url need add phpsessionidSID is constant value replace phpsessionid1234$redirect_url = 'http://www.example.com';if(defined('SID') &amp;&amp; (! isset($_COOKIE[session_name()])))&#123; $redirect_url .= '?' . SID&#125; output_add_rewrite_var ( string $name , string $value ) : bool1output_add_rewrite_var('token', $token); 此函数给URL重写机制添加名/值对。 这种名值对将被添加到URL（以GET参数的形式）和表单（以input隐藏域的形式），当透明URL重写用 session.use_trans_sid 开启时同样可以添加到session ID。 要注意，绝对URL(http://example.com/..)不能被重写。 force use cookie, url not contain phpsessionid123ini_set('session.use_only_cookies', true)session_regenerate_id();]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP Laravel]]></title>
    <url>%2Fphp%2Flaravel%2Ftimeline.html</url>
    <content type="text"><![CDATA[learning laravel install homestead vagrant box git clone https://github.com/laravel/homestead.git Homestead laravel local server init php artisan serve –host=0.0.0.0 –port=8000]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP protected from crsf attack]]></title>
    <url>%2Fphp%2Fsecure%2Fphp_CRSF_TOKEN.html</url>
    <content type="text"><![CDATA[php protected from crsf attackgenerate token1234567891011&lt;?phpsession_start();if (empty($_SESSION['token'])) &#123; if (function_exists('mcrypt_create_iv')) &#123; $_SESSION['token'] = bin2hex(mcrypt_create_iv(32, MCRYPT_DEV_URANDOM)); &#125; else &#123; $_SESSION['token'] = bin2hex(openssl_random_pseudo_bytes(32)); &#125;&#125;$token = $_SESSION['token'];?&gt; form use token123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;CSRF&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method="post" action=""&gt; &lt;input type="text" name="username"&gt; &lt;br&gt; &lt;input type="text" name="password"&gt;&lt;br&gt; &lt;input type="text" name="token" value="&lt;?php echo $_SESSION['token']; ?&gt;"&gt;&lt;br&gt; &lt;input type="submit" value="submit"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; request handler1234567if (!empty($_POST['token'])) &#123; if (hash_equals($_SESSION['token'], $_POST['token'])) &#123; &#125; else &#123; &#125;&#125;]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>crsf</tag>
        <tag>web attack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP protected from sql inject]]></title>
    <url>%2Fphp%2Fsecure%2Fphp_SQL_inject.html</url>
    <content type="text"><![CDATA[PHP protected from sql injectPDOinsert123456$db = new PDO("sqlite:/tmp.db");$sql = "insert into auth (time, user) values(?, ?)";$query = $db-&gt;prepare($sql);if($query-&gt;execute(array($time, $user)))&#123; echo "insert success";&#125; select123456$db = new PDO("sqlite:/tmp.db");$sql = "select * from tmp where ip=? or user=?";$query = $db-&gt;prepare($sql);$query-&gt;execute(array($ip, $user));$rows = $query-&gt;fetchAll(PDO::FETCH_ASSOC);var_dump($rows);]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>web attack</tag>
        <tag>sql inject</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django basic commands]]></title>
    <url>%2Fpython%2Fdjango%2Fbasic_command.html</url>
    <content type="text"><![CDATA[django basic commandscreate projectdjango-admin.py startproject project_name create appdjango-admin.py startapp appname synchro database python manange.py makemigrations python manange.py migrate run by test serverpython manange.py runserver 127.0.0.1:8888 clear databasepython manange.py flush create super userpython manange.py createsuperuser change user passwordpython manange.py changepassword username dump databasepython manange.py dumpdata appname &gt; appname.json load databasepython manange.py loaddata appname.json django shellpython manange.py shell database sql shellpython manange.py dbshell]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[install pip]]></title>
    <url>%2Fpython%2Finstall%2FPip.html</url>
    <content type="text"><![CDATA[install pip2 and pip3123wget https://bootstrap.pypa.io/get-pip.pysudo python2 get-pip.pysudo python get-pip.py]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlite common cmd 常用命令]]></title>
    <url>%2Fdatabases%2Fsqlite%2Fsqlite_common_cmd.html</url>
    <content type="text"><![CDATA[sqlite common cmd 常用命令查看列表名 pragma table_info(tablename); .schema tablename select * from sqlite_master where type=”table” and name=”tablename”; 退出sqlite shel.exit 显示所有table.tables]]></content>
      <categories>
        <category>sqlite</category>
      </categories>
      <tags>
        <tag>sqlite</tag>
        <tag>sql</tag>
        <tag>common</tag>
      </tags>
  </entry>
</search>
