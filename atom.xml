<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>moonclearner page</title>
  
  <subtitle>moonclearner blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://moonclearner.cn/"/>
  <updated>2021-03-04T07:33:57.030Z</updated>
  <id>https://moonclearner.cn/</id>
  
  <author>
    <name>moonclearner</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>github加快</title>
    <link href="https://moonclearner.cn/github%E5%8A%A0%E5%BF%AB.html"/>
    <id>https://moonclearner.cn/github加快.html</id>
    <published>2021-03-04T07:30:34.000Z</published>
    <updated>2021-03-04T07:33:57.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="加快github-clone速度"><a href="#加快github-clone速度" class="headerlink" title="加快github clone速度"></a>加快github clone速度</h1><p>执行以下配置命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global url.&quot;https://github.com.cnpmjs.org/&quot;.insteadOf &quot;https://github.com/&quot;</span><br></pre></td></tr></table></figure><p>或直接修改~/.gitconfig文件，添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[url &quot;https://github.com.cnpmjs.org/&quot;]</span><br><span class="line">insteadOf = https://github.com/</span><br></pre></td></tr></table></figure><p>以上配置，仅对https协议生效，对SSH协议不生效。 在URL替换后，仓库里的配置直接时基于<a href="https://github.com.cnpmjs.org/的。" target="_blank" rel="noopener">https://github.com.cnpmjs.org/的。</a> 如果需要换回来，或者换成SSH协议，则需要使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin ...</span><br></pre></td></tr></table></figure><p>或者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add github ...</span><br></pre></td></tr></table></figure></p><p>由于GitHub增量下载，还是勉强能接受的，因此在clone后把URL换回来，或者多remote管理，也是可行方案。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;加快github-clone速度&quot;&gt;&lt;a href=&quot;#加快github-clone速度&quot; class=&quot;headerlink&quot; title=&quot;加快github clone速度&quot;&gt;&lt;/a&gt;加快github clone速度&lt;/h1&gt;&lt;p&gt;执行以下配置命令：&lt;/p&gt;

      
    
    </summary>
    
      <category term="python" scheme="https://moonclearner.cn/categories/python/"/>
    
    
      <category term="pytho" scheme="https://moonclearner.cn/tags/pytho/"/>
    
  </entry>
  
  <entry>
    <title>python 操作大小端十六进制</title>
    <link href="https://moonclearner.cn/python-%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6.html"/>
    <id>https://moonclearner.cn/python-操作大小端十六进制.html</id>
    <published>2021-03-04T07:18:27.000Z</published>
    <updated>2021-03-04T07:27:46.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="整形大小端转化和输出ip16进制"><a href="#整形大小端转化和输出ip16进制" class="headerlink" title="整形大小端转化和输出ip16进制"></a>整形大小端转化和输出ip16进制</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> fcntl</span><br><span class="line"><span class="keyword">import</span> struc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">int_bytes_reverse</span><span class="params">(self, int_data, byte_num)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    int_data = 202  byte_num=4</span></span><br><span class="line"><span class="string">    1. raw_str = "00000000ca"</span></span><br><span class="line"><span class="string">    2. byte_reverse = "ca000000"</span></span><br><span class="line"><span class="string">    3. retutn "\xca\00\00\00"</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    raw_str = <span class="string">""</span>.join([<span class="string">"00"</span>]*byte_num) + hex(int_data)[<span class="number">2</span>:]</span><br><span class="line">    byte_reverse = raw_str[-byte_num*<span class="number">2</span>:].decode(<span class="string">"hex"</span>)[::<span class="number">-1</span>].encode(<span class="string">"hex"</span>)</span><br><span class="line">    <span class="keyword">return</span> binascii.unhexlify(byte_reverse)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ipv6_str</span><span class="params">(self, ipv6_addr, reverse=False)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    ipv6_addr -&gt; 1::1</span></span><br><span class="line"><span class="string">    return '\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01'</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> reverse:</span><br><span class="line">            <span class="keyword">return</span> socket.inet_pton(socket.AF_INET6, ipv6_addr)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> socket.inet_pton(socket.AF_INET6, ipv6_addr)[::<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">except</span> socket.error:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> reverse:</span><br><span class="line">            <span class="keyword">return</span> socket.inet_pton(socket.AF_INET6, <span class="string">"::"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> socket.inet_pton(socket.AF_INET6, <span class="string">"::"</span>)[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ipv4_str</span><span class="params">(self, ipv4_addr, reverse=False)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    ipv6_addr -&gt; 192.168.42.231</span></span><br><span class="line"><span class="string">    return '\xe7*\xa8\xc0'</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> reverse:</span><br><span class="line">            <span class="keyword">return</span> socket.inet_pton(socket.AF_INET, ipv4_addr)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> socket.inet_pton(socket.AF_INET, ipv4_addr)[::<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">except</span> socket.error:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> reverse:</span><br><span class="line">            <span class="keyword">return</span> socket.inet_pton(socket.AF_INET, <span class="string">"0.0.0.0"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> socket.inet_pton(socket.AF_INET, <span class="string">"0.0.0.0"</span>)[::<span class="number">-1</span></span><br></pre></td></tr></table></figure><h2 id="字符串大小端转化"><a href="#字符串大小端转化" class="headerlink" title="字符串大小端转化"></a>字符串大小端转化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">"017f00373137323a333233323234363530333a303a34333630353a333339363038313239333a303a38303a363a2f6d74782f64617461"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">''</span>.join([hex(ord(c)).replace(<span class="string">'0x'</span>, <span class="string">''</span>) <span class="keyword">for</span> c <span class="keyword">in</span> a]).decode(<span class="string">"hex"</span>)[::<span class="number">-1</span>].encode(<span class="string">"hex"</span>)</span><br><span class="line"><span class="string">'303030323a706163702e32312d3732303030303030312d3634313238312d33313530303230322d303637373734363236332f3134312e32322e3830312e3230322f302f73656c69667061632f617461642f78746d2f3a363a30383a303a333932313830363933333a35303633343a303a333035363432323332333a32373137'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">''</span>.join([hex(ord(c)).replace(<span class="string">'0x'</span>, <span class="string">''</span>) <span class="keyword">for</span> c <span class="keyword">in</span> a])   </span><br><span class="line"><span class="string">"373137323a333233323234363530333a303a34333630353a333339363038313239333a303a38303a363a2f6d74782f646174612f63617066696c65732f302f3230322e3130382e32322e3134312f333632363437373736302d32303230303531332d3138323134362d3130303030303032372d31322e706361703a32303030"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;整形大小端转化和输出ip16进制&quot;&gt;&lt;a href=&quot;#整形大小端转化和输出ip16进制&quot; class=&quot;headerlink&quot; title=&quot;整形大小端转化和输出ip16进制&quot;&gt;&lt;/a&gt;整形大小端转化和输出ip16进制&lt;/h1&gt;&lt;figure class=&quot;hi
      
    
    </summary>
    
      <category term="python" scheme="https://moonclearner.cn/categories/python/"/>
    
    
      <category term="python" scheme="https://moonclearner.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>php xdebug note</title>
    <link href="https://moonclearner.cn/php-xdebug-note.html"/>
    <id>https://moonclearner.cn/php-xdebug-note.html</id>
    <published>2021-01-28T06:57:32.000Z</published>
    <updated>2021-01-29T02:11:24.875Z</updated>
    
    <content type="html"><![CDATA[<h2 id="php-ini"><a href="#php-ini" class="headerlink" title="php.ini"></a>php.ini</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[Xdebug]</span><br><span class="line">xdebug.remote_enable = on</span><br><span class="line">xdebug.remote_host = 10.66.35.88</span><br><span class="line">xdebug.remote_port = 9001</span><br><span class="line">xdebug.remote_log = /tmp/xdebug.log</span><br><span class="line"></span><br><span class="line">xdebug.default_enable=on</span><br><span class="line">xdebug.collect_params=4</span><br><span class="line">xdebug.collect_return=1</span><br><span class="line">xdebug.trace_enable_trigger=1</span><br><span class="line">xdebug.trace_output_dir=&quot;/tmp/xdebug&quot;</span><br><span class="line">xdebug.trace_output_name=trace.%c.%p</span><br><span class="line"></span><br><span class="line">xdebug.profiler_enable_trigger=1</span><br><span class="line">xdebug.profiler_output_dir=&quot;/tmp/xdebug&quot;</span><br><span class="line">xdebug.profiler_output_name=&quot;cachegrind.out.%s&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;php-ini&quot;&gt;&lt;a href=&quot;#php-ini&quot; class=&quot;headerlink&quot; title=&quot;php.ini&quot;&gt;&lt;/a&gt;php.ini&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ubuntu best software</title>
    <link href="https://moonclearner.cn/ubuntu/best_software.html"/>
    <id>https://moonclearner.cn/ubuntu/best_software.html</id>
    <published>2021-01-04T02:55:01.183Z</published>
    <updated>2021-01-04T02:55:01.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cpu-内存-网速显示"><a href="#cpu-内存-网速显示" class="headerlink" title="cpu 内存 网速显示"></a>cpu 内存 网速显示</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitor</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install indicator-sysmonitor</span><br><span class="line"></span><br><span class="line">indicator-sysmonitor</span><br></pre></td></tr></table></figure><h2 id="远程连接windos"><a href="#远程连接windos" class="headerlink" title="远程连接windos"></a>远程连接windos</h2><h3 id="rdesktop"><a href="#rdesktop" class="headerlink" title="rdesktop"></a>rdesktop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdesktop -g 1800x1000 10.66.1.1 -r disk:linuxShare=/home/daijianjian/share -x 0x80 -r clipboard:CLIPBOARD -r sound:local</span><br></pre></td></tr></table></figure><p><code>-r disk:linuxShare=/home/user/share</code> 用于共享文件</p><p><code>-r clipboard:CLIPBOARD</code>  粘贴板共享</p><p><strong>当出现粘贴板失灵</strong> 需要关闭远程win的rdpclip.exe进程，然后再远程即可完成进行重启</p><p><code>-r sound:local</code> 开启远程的声音</p><h3 id="teamview"><a href="#teamview" class="headerlink" title="teamview"></a>teamview</h3><h3 id="向日葵"><a href="#向日葵" class="headerlink" title="向日葵"></a>向日葵</h3><h2 id="百度云有linux版本"><a href="#百度云有linux版本" class="headerlink" title="百度云有linux版本"></a>百度云有linux版本</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;cpu-内存-网速显示&quot;&gt;&lt;a href=&quot;#cpu-内存-网速显示&quot; class=&quot;headerlink&quot; title=&quot;cpu 内存 网速显示&quot;&gt;&lt;/a&gt;cpu 内存 网速显示&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
      
    
    </summary>
    
      <category term="tool" scheme="https://moonclearner.cn/categories/tool/"/>
    
    
      <category term="ubuntu" scheme="https://moonclearner.cn/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>wine setting</title>
    <link href="https://moonclearner.cn/ubuntu/deepin-wine.html"/>
    <id>https://moonclearner.cn/ubuntu/deepin-wine.html</id>
    <published>2021-01-04T02:40:06.716Z</published>
    <updated>2021-01-04T02:40:06.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件文字显示方块（如企业微信）"><a href="#软件文字显示方块（如企业微信）" class="headerlink" title="软件文字显示方块（如企业微信）"></a>软件文字显示方块（如企业微信）</h1><ul><li>去windows 系统 上去复制一份Fonts字体</li><li>复制到你要修复的wine容器 将字体放入~/.wine/drive_c/windows/Fonts 里面，如果是deepin的话，就放在~/.deepinwine/XXX/drive_c/windows/Fonts里面（XXX指deepin下的你安装的程序）</li><li><p>创建一份字体加载注册脚本 <code>touch zh.reg</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">REGEDIT4</span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\FontLink\SystemLink]</span><br><span class="line">&quot;Lucida Sans Unicode&quot;=&quot;msyh.ttc&quot;</span><br><span class="line">&quot;Microsoft Sans Serif&quot;=&quot;msyh.ttc&quot;</span><br><span class="line">&quot;MS Sans Serif&quot;=&quot;msyh.ttc&quot;</span><br><span class="line">&quot;Tahoma&quot;=&quot;msyh.ttc&quot;</span><br><span class="line">&quot;Tahoma Bold&quot;=&quot;msyhbd.ttc&quot;</span><br><span class="line">&quot;msyh&quot;=&quot;msyh.ttc&quot;</span><br><span class="line">&quot;Arial&quot;=&quot;msyh.ttc&quot;</span><br><span class="line">&quot;Arial Black&quot;=&quot;msyh.ttc&quot;</span><br></pre></td></tr></table></figure></li><li><p><code>WINEPREFIX=~/.deepinwine/Deepin-WXWork /usr/bin/deepin-wine regedit zh.reg</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件文字显示方块（如企业微信）&quot;&gt;&lt;a href=&quot;#软件文字显示方块（如企业微信）&quot; class=&quot;headerlink&quot; title=&quot;软件文字显示方块（如企业微信）&quot;&gt;&lt;/a&gt;软件文字显示方块（如企业微信）&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;去windows 系统 
      
    
    </summary>
    
      <category term="wine" scheme="https://moonclearner.cn/categories/wine/"/>
    
    
      <category term="ubuntu" scheme="https://moonclearner.cn/tags/ubuntu/"/>
    
      <category term="wine" scheme="https://moonclearner.cn/tags/wine/"/>
    
      <category term="deep-win" scheme="https://moonclearner.cn/tags/deep-win/"/>
    
  </entry>
  
  <entry>
    <title>sqlNote</title>
    <link href="https://moonclearner.cn/databases/sql/sqlNote.html"/>
    <id>https://moonclearner.cn/databases/sql/sqlNote.html</id>
    <published>2020-11-24T11:45:00.943Z</published>
    <updated>2020-11-24T11:45:00.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sql-Note"><a href="#sql-Note" class="headerlink" title="sql Note"></a>sql Note</h1><h2 id="优化途径"><a href="#优化途径" class="headerlink" title="优化途径"></a>优化途径</h2><h3 id="关联查询，先过滤后关联"><a href="#关联查询，先过滤后关联" class="headerlink" title="关联查询，先过滤后关联"></a>关联查询，先过滤后关联</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select * from table1,table2 where 这个是先关联后过滤</span><br><span class="line"></span><br><span class="line">select * from table1,table2 where 这个是先关联后过滤</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sql-Note&quot;&gt;&lt;a href=&quot;#sql-Note&quot; class=&quot;headerlink&quot; title=&quot;sql Note&quot;&gt;&lt;/a&gt;sql Note&lt;/h1&gt;&lt;h2 id=&quot;优化途径&quot;&gt;&lt;a href=&quot;#优化途径&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="sql" scheme="https://moonclearner.cn/categories/sql/"/>
    
    
      <category term="sql" scheme="https://moonclearner.cn/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>postgresql tablespace</title>
    <link href="https://moonclearner.cn/databases/postgresql/tablespace.html"/>
    <id>https://moonclearner.cn/databases/postgresql/tablespace.html</id>
    <published>2020-11-23T07:37:30.300Z</published>
    <updated>2020-11-23T07:37:30.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Table-Space"><a href="#Table-Space" class="headerlink" title="Table Space"></a>Table Space</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>设备上有两块存储单元A（ROM）和B（RAM）都有一个表空间存放在AB上</p><p>由于B随着设备重启会重置，数据库的初始化应该放在A上</p><p>然后在A和B上创建对应的表空间</p><p>创建表放在A和B上的表空间上，但是注意，如果只是在表创建时，指定表空间，其约束也要指定表空间，或者设置一个默认表空间设置，然后在执行创建表，这样整个表的所有信息都指定到这个表空间上,这些约束包括，分表、id自增、外键等等</p><h2 id="如何删除表空间"><a href="#如何删除表空间" class="headerlink" title="如何删除表空间"></a>如何删除表空间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop tablespace spacename</span><br></pre></td></tr></table></figure><p>当表空间里面存在各类表的时候，是不能直接删除表空间的，即使是删除了表空间的路径</p><p>需要先把表空间的表移动到其他表空间里面或者删除表空间里面的表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select schemaname, tablename from pg_tables where tablespace=&apos;tablespacename&apos;</span><br><span class="line"></span><br><span class="line">在postgresql可以查到所有关于表空间tablespacename的表</span><br><span class="line"></span><br><span class="line">然后可以考虑是删除还是移动到其他表空间里面</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Table-Space&quot;&gt;&lt;a href=&quot;#Table-Space&quot; class=&quot;headerlink&quot; title=&quot;Table Space&quot;&gt;&lt;/a&gt;Table Space&lt;/h1&gt;&lt;h2 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;
      
    
    </summary>
    
      <category term="postgresql" scheme="https://moonclearner.cn/categories/postgresql/"/>
    
    
      <category term="postgresql" scheme="https://moonclearner.cn/tags/postgresql/"/>
    
  </entry>
  
  <entry>
    <title>mysql learning note</title>
    <link href="https://moonclearner.cn/databases/mysql/notes.html"/>
    <id>https://moonclearner.cn/databases/mysql/notes.html</id>
    <published>2020-11-20T07:20:58.776Z</published>
    <updated>2020-11-20T07:20:58.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql-learning-note"><a href="#mysql-learning-note" class="headerlink" title="mysql learning note"></a>mysql learning note</h1><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>查询原因：</p><ul><li>没有命中索引</li><li>没有分页处理</li></ul><h3 id="最大数据量"><a href="#最大数据量" class="headerlink" title="最大数据量"></a>最大数据量</h3><p>MySQL没有限制单位最大记录数，其取决于os以及文件系统对单文件最大的限制</p><h3 id="最大并发数"><a href="#最大并发数" class="headerlink" title="最大并发数"></a>最大并发数</h3><p>由maxconnections和maxuserconnections决定</p><p>maxconnections是指MySQL实例的最大连接数，上限值是16384，maxuserconnections是指每个数据库用户的最大连接数</p><p>MySQL会为每个连接提供缓冲区，意味着消耗更多的内存。如果连接数设置太高硬件吃不消，太低又不能充分利用硬件。一般要求两者比值超过10%，计算方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_used_connections / max_connections * 100% = 3/100 *100% ≈ 3%</span><br></pre></td></tr></table></figure></p><p>查看最大连接数与响应最大连接数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;%max_connections%&apos;;</span><br><span class="line">show variables like &apos;%max_user_connections%&apos;;</span><br></pre></td></tr></table></figure></p><p>在配置文件my.cnf中修改最大连接数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]max_connections = 100max_used_connections = 20</span><br></pre></td></tr></table></figure></p><h3 id="查询耗时0-5秒"><a href="#查询耗时0-5秒" class="headerlink" title="查询耗时0.5秒"></a>查询耗时0.5秒</h3><p>建议将单次查询耗时控制在0.5秒以内，0.5秒是个经验值，源于用户体验的3秒原则 。如果用户的操作3秒内没有响应，将会厌烦甚至退出。响应时间=客户端UI渲染耗时+网络请求耗时+应用程序处理耗时+查询数据库耗时，0.5秒就是留给数据库1/6的处理时间</p><h3 id="实施原则"><a href="#实施原则" class="headerlink" title="实施原则"></a>实施原则</h3><p>相比NoSQL数据库，MySQL容量小并发低、SQL约束太多。应用程序扩容比数据库要容易得多，所以实施原则是 <strong>数据库少干活，应用程序多干活</strong></p><ul><li>充分利用但不滥用索引，须知索引也消耗磁盘和CPU。</li><li>不推荐使用数据库函数格式化数据，交给应用程序处理。</li><li>不推荐使用外键约束，用应用程序保证数据准确性。</li><li>写多读少的场景，不推荐使用唯一索引，用应用程序保证唯一性。</li><li>适当冗余字段，尝试创建中间表，用应用程序计算中间结果，用空间换时间。</li><li>不允许执行极度耗时的事务，配合应用程序拆分成更小的事务。</li><li>预估重要数据表（比如订单表）的负载和数据增长态势，提前优化。</li></ul><h2 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><strong>数据类型的选择原则：更简单或者占用空间更小</strong></p><ul><li>如果长度能够满足，整型尽量使用tinyint、smallint、medium_int而非int</li><li>如果字符串长度确定，采用char类型</li><li>如果varchar能够满足，不采用text类型</li><li>精度要求较高的使用decimal类型，也可以使用BIGINT，比如精确两位小数就乘以100后保存</li><li>尽量采用timestamp而非datetime</li></ul><table><thead><tr><th>类型</th><th>占据字节</th><th>描述</th></tr></thead><tbody><tr><td>datetime</td><td>8个字节</td><td>‘1000-01-01 00:00:00.000000’ to ‘9999-12-31 23:59:59.999999</td></tr><tr><td>timestamp</td><td>4字节</td><td>‘1970-01-01 00:00:01.000000’ to ‘2038-01-19 03:14:07.999999’</td></tr></tbody></table><h3 id="avoid-null-value"><a href="#avoid-null-value" class="headerlink" title="avoid null value"></a>avoid null value</h3><p>MySQL中字段为NULL时依然占用空间，会使索引、索引统计更加复杂。从NULL值更新到非NULL无法做到原地更新，容易发生索引分裂影响性能。尽可能将NULL值用有意义的值代替，也能避免SQL语句里面包含 is not null的判断</p><h3 id="text-type-Optimization"><a href="#text-type-Optimization" class="headerlink" title="text type Optimization"></a>text type Optimization</h3><p>由于text字段储存大量数据，表容量会很早涨上去，影响其他字段的查询性能。建议抽取出来放在子表里，用业务主键关联</p><h2 id="引索optimization"><a href="#引索optimization" class="headerlink" title="引索optimization"></a>引索optimization</h2><h3 id="index-分类"><a href="#index-分类" class="headerlink" title="index 分类"></a>index 分类</h3><ul><li>普通索引：最基本的索引。</li><li>组合索引：多个字段上建立的索引，能够加速复合查询条件的检索。</li><li>唯一索引：与普通索引类似，但索引列的值必须唯一，允许有空值。</li><li>组合唯一索引：列值的组合必须唯一。</li><li>主键索引：特殊的唯一索引，用于唯一标识数据表中的某一条记录，不允许有空值，一般用primary key约束。</li><li>全文索引：用于海量文本的查询，MySQL5.6之后的InnoDB和MyISAM均支持全文索引。由于查询精度以及扩展性不佳，更多的企业选择Elasticsearch。</li></ul><h3 id="index-optimization"><a href="#index-optimization" class="headerlink" title="index optimization"></a>index optimization</h3><ul><li>分页查询很重要，如果查询数据量超过30%，MYSQL不会使用索引。</li><li>单表索引数不超过5个、单个索引字段数不超过5个。</li><li>字符串可使用前缀索引，前缀长度控制在5-8个字符。</li><li>字段唯一性太低，增加索引没有意义，如：是否删除、性别。</li><li>合理使用覆盖索引，如下所示：<br>  select loginname, nickname from member where login_name = ?<br>  loginname, nickname两个字段建立组合索引，比login_name简单索引要更快</li></ul><h2 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h2><h3 id="batch"><a href="#batch" class="headerlink" title="batch"></a>batch</h3><p>当一条sql语句会处理整个表的数据的时候，有可能会堵塞其他sql运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update status=0 FROMcoupon WHERE expire_date &lt;= #&#123;currentDate&#125; and status=1;</span><br></pre></td></tr></table></figure></p><p>因此可以使用分批操作</p><h4 id="optimization"><a href="#optimization" class="headerlink" title="optimization"></a>optimization</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int pageNo = 1;</span><br><span class="line">int PAGE_SIZE = 100;</span><br><span class="line">while(true) &#123;</span><br><span class="line">    List&lt;Integer&gt; batchIdList = queryList(&apos;select id FROM `coupon` WHERE expire_date &lt;= #&#123;currentDate&#125; and status = 1 limit #&#123;(pageNo-1) * PAGE_SIZE&#125;,#&#123;PAGE_SIZE&#125;&apos;);</span><br><span class="line">    if (CollectionUtils.isEmpty(batchIdList)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    update(&apos;update status = 0 FROM `coupon` where status = 1 and id in #&#123;batchIdList&#125;&apos;)</span><br><span class="line">    pageNo ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="operation-lt-gt-optimization"><a href="#operation-lt-gt-optimization" class="headerlink" title="operation &lt;&gt; optimization"></a>operation &lt;&gt; optimization</h3><p>通常&lt;&gt;操作符无法使用索引，举例如下，查询金额不为100元的订单：select id from orders where amount != 100;如果金额为100的订单极少，这种数据分布严重不均的情况下，有可能使用索引。鉴于这种不确定性，采用union聚合搜索结果，改写方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(select id from orders where amount &gt; 100) union all(select id from orders where amount &lt; 100 and amount &gt; 0)</span><br></pre></td></tr></table></figure></p><h3 id="operation-or-optimization"><a href="#operation-or-optimization" class="headerlink" title="operation or optimization"></a>operation or optimization</h3><p>在Innodb引擎下or无法使用组合索引，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id，product_name from orders where mobile_no = &apos;13421800407&apos; or user_id = 100;</span><br></pre></td></tr></table></figure></p><p>OR无法命中mobileno + userid的组合索引，可采用union，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(select id，product_name from orders where mobile_no = &apos;13421800407&apos;) union(select id，product_name from orders where user_id = 100);</span><br></pre></td></tr></table></figure></p><p>此时id和product_name字段都有索引，查询才最高效。</p><h3 id="operation-in-optimization"><a href="#operation-in-optimization" class="headerlink" title="operation in optimization"></a>operation in optimization</h3><ul><li>IN适合主表大子表小，EXIST适合主表小子表大。由于查询优化器的不断升级，很多场景这两者性能差不多一样了。</li><li>尝试改为join查询，举例如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id from orders where user_id in (select id from user where level = &apos;VIP&apos;);</span><br><span class="line">采用JOIN如下所示：</span><br><span class="line">select o.id from orders o left join user u on o.user_id = u.id where u.level = &apos;VIP&apos;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="不做列运算"><a href="#不做列运算" class="headerlink" title="不做列运算"></a>不做列运算</h3><p>通常在查询条件列运算会导致索引失效，如下所示：查询当日订单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from order where date_format(create_time，&apos;%Y-%m-%d&apos;) = &apos;2019-07-01&apos;;</span><br></pre></td></tr></table></figure></p><p>date_format函数会导致这个查询无法使用索引，改写后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from order where create_time between &apos;2019-07-01 00:00:00&apos; and &apos;2019-07-01 23:59:59&apos;;</span><br></pre></td></tr></table></figure></p><h3 id="avoid-Select-all"><a href="#avoid-Select-all" class="headerlink" title="avoid Select all"></a>avoid Select all</h3><p>如果不查询表中所有的列，避免使用 SELECT *，它会进行全表扫描，不能有效利用索引。</p><h3 id="operation-like-optimization"><a href="#operation-like-optimization" class="headerlink" title="operation like optimization"></a>operation like optimization</h3><p>like用于模糊查询，举个例子（field已建立索引）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT column FROM table WHERE field like &apos;%keyword%&apos;;</span><br></pre></td></tr></table></figure></p><p>这个查询未命中索引，换成下面的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT column FROM table WHERE field like &apos;keyword%&apos;;</span><br></pre></td></tr></table></figure></p><p>去除了前面的%查询将会命中索引，但是产品经理一定要前后模糊匹配呢？全文索引fulltext可以尝试一下，但Elasticsearch才是终极武器。</p><h3 id="operation-Join-optimization"><a href="#operation-Join-optimization" class="headerlink" title="operation Join optimization"></a>operation Join optimization</h3><p>join的实现是采用Nested Loop Join算法，就是通过驱动表的结果集作为基础数据，通过该结数据作为过滤条件到下一个表中循环查询数据，然后合并结果。如果有多个join，则将前面的结果集作为循环数据，再次到后一个表中查询数据。</p><ul><li>驱动表和被驱动表尽可能增加查询条件，满足ON的条件而少用Where，用小结果集驱动大结果集。</li><li>被驱动表的join字段上加上索引，无法建立索引的时候，设置足够的Join Buffer Size。</li><li>禁止join连接三个以上的表，尝试增加冗余字段。</li></ul><h3 id="oper-Limit-optimization"><a href="#oper-Limit-optimization" class="headerlink" title="oper Limit optimization"></a>oper Limit optimization</h3><p>limit用于分页查询时越往后翻性能越差，解决的原则：缩小扫描范围 ，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from orders order by id desc limit 100000,10 耗时0.4秒</span><br><span class="line">select * from orders order by id desc limit 1000000,10耗时5.2秒</span><br></pre></td></tr></table></figure></p><p>先筛选出ID缩小查询范围，写法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from orders where id &gt; (select id from orders order by id desc  limit 1000000, 1) order by id desc limit 0,10耗时0.5秒</span><br></pre></td></tr></table></figure></p><p>如果查询条件仅有主键ID，写法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from orders where id between 1000000 and 1000010 order by id desc耗时0.3秒</span><br></pre></td></tr></table></figure></p><p>如果以上方案依然很慢呢？只好用游标了，感兴趣的朋友阅读JDBC使用游标实现分页查询的方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mysql-learning-note&quot;&gt;&lt;a href=&quot;#mysql-learning-note&quot; class=&quot;headerlink&quot; title=&quot;mysql learning note&quot;&gt;&lt;/a&gt;mysql learning note&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="mysql" scheme="https://moonclearner.cn/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://moonclearner.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>tornado</title>
    <link href="https://moonclearner.cn/web%E5%B9%B6%E5%8F%91.html"/>
    <id>https://moonclearner.cn/web并发.html</id>
    <published>2020-11-20T06:41:14.000Z</published>
    <updated>2020-11-20T07:14:30.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tornado"><a href="#Tornado" class="headerlink" title="Tornado"></a>Tornado</h1><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>提升硬件</li><li>关系型数据库-》内存数据库</li><li>采用类似tornado异步非阻塞框架</li><li>认证由单台memcache换成redis集群</li><li>日志改为定时写</li><li>机器数量单台改为多台</li></ul><h2 id="tornado"><a href="#tornado" class="headerlink" title="tornado"></a>tornado</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><h4 id="IOLoop"><a href="#IOLoop" class="headerlink" title="IOLoop"></a>IOLoop</h4><p>使用IOLoop来处理socket读写事件，IOLoop是基于epoll,可以高效的响应网络事件</p><h4 id="IOStream"><a href="#IOStream" class="headerlink" title="IOStream"></a>IOStream</h4><p>使用IOStream为对socket进行异步处理，</p><h4 id="HTTPConnection"><a href="#HTTPConnection" class="headerlink" title="HTTPConnection"></a>HTTPConnection</h4><p>处理Http头以及读取post的数据</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>单进程单线程</li><li>非阻塞式异步请求</li></ol><h3 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h3><img src="/web并发/2013_10_14_05.gif" title="img">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tornado&quot;&gt;&lt;a href=&quot;#Tornado&quot; class=&quot;headerlink&quot; title=&quot;Tornado&quot;&gt;&lt;/a&gt;Tornado&lt;/h1&gt;&lt;h2 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>沙箱</title>
    <link href="https://moonclearner.cn/%E6%B2%99%E7%AE%B1.html"/>
    <id>https://moonclearner.cn/沙箱.html</id>
    <published>2020-11-20T03:47:38.000Z</published>
    <updated>2020-11-20T06:27:24.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a>沙箱</h1><h2 id="基于信誉"><a href="#基于信誉" class="headerlink" title="基于信誉"></a>基于信誉</h2><p>包含 URL、文件</p><h2 id="基于病毒库"><a href="#基于病毒库" class="headerlink" title="基于病毒库"></a>基于病毒库</h2><h2 id="基于静态检测"><a href="#基于静态检测" class="headerlink" title="基于静态检测"></a>基于静态检测</h2><h3 id="yara"><a href="#yara" class="headerlink" title="yara"></a>yara</h3><p>用于识别和分类恶意软件样本的开源工具</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ul><li>office文件</li><li>flash文件</li><li>pdf文件</li><li>网页文件</li></ul><h2 id="动态检测"><a href="#动态检测" class="headerlink" title="动态检测"></a>动态检测</h2><h3 id="基于虚拟机或者容器"><a href="#基于虚拟机或者容器" class="headerlink" title="基于虚拟机或者容器"></a>基于虚拟机或者容器</h3><h3 id="沙箱逃逸"><a href="#沙箱逃逸" class="headerlink" title="沙箱逃逸"></a>沙箱逃逸</h3><p>由于沙箱不是真实物理环境，恶意软件当发现不是真实环境，则会反调试、反虚拟化，这个就是沙箱逃避</p><h4 id="常见手段"><a href="#常见手段" class="headerlink" title="常见手段"></a>常见手段</h4><ul><li>恶意软件会休眠很久在开始攻击<ul><li>加快沙箱的运行速度</li></ul></li><li>恶意软件通过查看注册表来看是否为沙箱<ul><li>屏蔽注册表的查看权限</li></ul></li></ul><h3 id="HOOk技术"><a href="#HOOk技术" class="headerlink" title="HOOk技术"></a>HOOk技术</h3><p>恶意软件在windows攻击都是调用Windows API进行相关的攻击，使用HOOK来监控系统调用知道攻击</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;沙箱&quot;&gt;&lt;a href=&quot;#沙箱&quot; class=&quot;headerlink&quot; title=&quot;沙箱&quot;&gt;&lt;/a&gt;沙箱&lt;/h1&gt;&lt;h2 id=&quot;基于信誉&quot;&gt;&lt;a href=&quot;#基于信誉&quot; class=&quot;headerlink&quot; title=&quot;基于信誉&quot;&gt;&lt;/a&gt;基于信誉&lt;/h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>国密</title>
    <link href="https://moonclearner.cn/%E5%9B%BD%E5%AF%86.html"/>
    <id>https://moonclearner.cn/国密.html</id>
    <published>2020-11-19T12:14:34.000Z</published>
    <updated>2020-11-20T02:51:54.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="国密"><a href="#国密" class="headerlink" title="国密"></a>国密</h1><h2 id="国密算法"><a href="#国密算法" class="headerlink" title="国密算法"></a>国密算法</h2><p>SM1、SM4、SM7 是分组对称密码算法，分组长度和密钥长度为128bit</p><p>SM1 算法安全保密强度于AES相当</p><p>SM4安全性高于3DES(加密文件)(16个字节)</p><p>SM7适用于非接触式IC卡</p><p>SM2 为椭圆曲线公钥密码算法，基于ECC。签名速度与密钥生产速度快与RSA。256位的SM2密码强度比2048位的RSA密码强度高</p><p>SM3是密码杂凑算法(摘要算法,32个字节)，适用于商业密码应用中的数字签名和验证消息认证码的生成和验证以及随机数的生成，SM3算法的安全性要高与MD5(16个字节)算法和SHA-1算法</p><p>SM9是与SM2、RSA类似的非对称加密算法。基于身份的密码体质，也就是公钥与用户的身份信息即标识相关，SM9的加密强度等同于3072位密钥的RSA加密算法</p><p>祖冲之序列密码算法是流密码算法，用于移动通信4G网络中的国际标准密码算法</p><h2 id="算法使用"><a href="#算法使用" class="headerlink" title="算法使用"></a>算法使用</h2><p>SM1 和SM7算法不公开,需要通过加密芯片的接口进行调用</p><p>SM2、SM3、SM4可通过加密芯片调用，也可以通过OpenSSL(1.1.1)、GMSSL、TaSSL调用实现</p><h2 id="标识"><a href="#标识" class="headerlink" title="标识"></a>标识</h2><p>由于国密是新的，很多识别不了国密算法</p><p>SM1   unknown 128<br>SM4   unknown 129<br>SM3   unknown 20<br>公钥数字信封鉴别方式 unknown 10</p><h2 id="国密双因子验证"><a href="#国密双因子验证" class="headerlink" title="国密双因子验证"></a>国密双因子验证</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li>ukey产生SM2签名密钥对，把公钥传给设备，设备与用户对应进行存储</li><li>设备生产随机数，并用公钥进行签名</li><li>设备把随机数与签名值传给ukey，ukey用私钥进行验签</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;国密&quot;&gt;&lt;a href=&quot;#国密&quot; class=&quot;headerlink&quot; title=&quot;国密&quot;&gt;&lt;/a&gt;国密&lt;/h1&gt;&lt;h2 id=&quot;国密算法&quot;&gt;&lt;a href=&quot;#国密算法&quot; class=&quot;headerlink&quot; title=&quot;国密算法&quot;&gt;&lt;/a&gt;国密算法&lt;/h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>漏洞验证</title>
    <link href="https://moonclearner.cn/%E6%BC%8F%E6%B4%9E%E9%AA%8C%E8%AF%81.html"/>
    <id>https://moonclearner.cn/漏洞验证.html</id>
    <published>2020-11-19T11:10:22.000Z</published>
    <updated>2020-11-20T02:51:57.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h1><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li>火狐浏览器及其插件 hackbar proxySwitcher</li><li>Curl</li><li>telnet</li><li>sqlmap</li><li>burpsuite</li><li>nmap<ul><li>网络扫描和嗅探工具包</li></ul></li><li>pentestbox</li><li>mobaxterm</li></ul><h2 id="the-ssl-dos攻击"><a href="#the-ssl-dos攻击" class="headerlink" title="the ssl dos攻击"></a>the ssl dos攻击</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;漏洞验证&quot;&gt;&lt;a href=&quot;#漏洞验证&quot; class=&quot;headerlink&quot; title=&quot;漏洞验证&quot;&gt;&lt;/a&gt;漏洞验证&lt;/h1&gt;&lt;h2 id=&quot;工具&quot;&gt;&lt;a href=&quot;#工具&quot; class=&quot;headerlink&quot; title=&quot;工具&quot;&gt;&lt;/a&gt;工具&lt;/h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>pythonyNote</title>
    <link href="https://moonclearner.cn/pythonyNote.html"/>
    <id>https://moonclearner.cn/pythonyNote.html</id>
    <published>2020-11-19T02:27:42.000Z</published>
    <updated>2020-11-19T11:09:47.535Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-Notes"><a href="#python-Notes" class="headerlink" title="python Notes"></a>python Notes</h1><h2 id="python2-and-python3"><a href="#python2-and-python3" class="headerlink" title="python2 and python3"></a>python2 and python3</h2><h3 id="pirnt"><a href="#pirnt" class="headerlink" title="pirnt"></a>pirnt</h3><h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><p>python3 input <- 123 -> str:123</-></p><p>python2 input <- 123 -> int:123</-></p><p>python2 raw_input <- 123 -> int:123</-></p><h3 id="整除"><a href="#整除" class="headerlink" title="整除"></a>整除</h3><p>python3 / 真除(返回整形) ； % 取余； // 取整</p><p>python2 / 带小数点真除(返回浮点)；  % 取余； // 取整</p><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>python3没有xrange</p><h3 id="try-except"><a href="#try-except" class="headerlink" title="try except"></a>try except</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    pass</span><br><span class="line">except Exception,e:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    pass</span><br><span class="line">except Exception as e:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>python2  file 和open<br>python3 只能open</p><h3 id="bytes数据类型"><a href="#bytes数据类型" class="headerlink" title="bytes数据类型"></a>bytes数据类型</h3><p>python3： 字符串以unicode编码存储，当写入二进制文件的时候，字符串无法直接写入（或者读取）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=gbk</span></span><br><span class="line">f = open(<span class="string">"test"</span>, <span class="string">"wb"</span>)</span><br><span class="line">s = <span class="string">"测试123abc"</span></span><br><span class="line">f.write(s) 在python2 可以直接写入</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在python3 需要将unicode加密为gbk才能写入</span></span><br><span class="line">b = s.encode(<span class="string">"gbk"</span>)</span><br><span class="line">f.write(s)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure></p><h3 id="async-and-await-python3-5引入"><a href="#async-and-await-python3-5引入" class="headerlink" title="async and await(python3.5引入)"></a>async and await(python3.5引入)</h3><p>异步函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">async def async_function():</span><br><span class="line">    return 1</span><br></pre></td></tr></table></figure></p><p>异步生成器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">async def async_generator():</span><br><span class="line">    yield 1</span><br></pre></td></tr></table></figure></p><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p>直接调用异步函数不会返回结果，而是返回一个coroutine对象</p><p>协程需要通过其他方式驱动，因此可以使用这个协程对象的send方法发送一个值<br>async_function().send(None)</p><h4 id="IO密集型应用和CPU密集型应用"><a href="#IO密集型应用和CPU密集型应用" class="headerlink" title="IO密集型应用和CPU密集型应用"></a>IO密集型应用和CPU密集型应用</h4><p>IO密集型应用：多进程-》多线程-》事件驱动-》协程<br>CPU密集应用：多进程-》多线程</p><h3 id="分布式开发"><a href="#分布式开发" class="headerlink" title="分布式开发"></a>分布式开发</h3><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><ul><li>gearman</li><li>rabbitmq</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;python-Notes&quot;&gt;&lt;a href=&quot;#python-Notes&quot; class=&quot;headerlink&quot; title=&quot;python Notes&quot;&gt;&lt;/a&gt;python Notes&lt;/h1&gt;&lt;h2 id=&quot;python2-and-python3&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="python" scheme="https://moonclearner.cn/categories/python/"/>
    
    
      <category term="python" scheme="https://moonclearner.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>pythony优化</title>
    <link href="https://moonclearner.cn/pythony%E4%BC%98%E5%8C%96.html"/>
    <id>https://moonclearner.cn/pythony优化.html</id>
    <published>2020-11-18T11:10:03.000Z</published>
    <updated>2020-11-19T06:42:32.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python优化"><a href="#python优化" class="headerlink" title="python优化"></a>python优化</h1><h2 id="处理文本-Unicode-三明治"><a href="#处理文本-Unicode-三明治" class="headerlink" title="处理文本-Unicode 三明治"></a>处理文本-Unicode 三明治</h2><ul><li>读取：将字节序列解码为字符串</li><li>处理：程序仅处理字符串</li><li>输出：将字符串编码为字节序列</li></ul><h3 id="编码建议"><a href="#编码建议" class="headerlink" title="编码建议"></a>编码建议</h3><ul><li>别依赖默认值</li><li>明确指定encoding</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>python2中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">open(&quot;test.txt&quot;).read() ---&gt; 返回的是字节序列</span><br><span class="line">open(&quot;test.txt&quot;).read().decode() ---&gt; 返回的是字节序列</span><br><span class="line"></span><br><span class="line">需要使用encode()将unicode转化为字节序列,然后写write()</span><br></pre></td></tr></table></figure></p><p>python3中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">open(&quot;test.txt&quot;).read() ---&gt; 返回的解码的串, 隐含了decode到unicode的操作</span><br><span class="line">open(&quot;test.txt&quot;,&quot;rb&quot;).read() ---&gt; 返回字节序列，禁用默认decode</span><br><span class="line"></span><br><span class="line">write() 隐含了unicode到字节序列的操作</span><br></pre></td></tr></table></figure></p><p>UTF-8可以用来表示Unicode标准中的任意字符</p><h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><h3 id="当程序里面有大量的实例"><a href="#当程序里面有大量的实例" class="headerlink" title="当程序里面有大量的实例"></a>当程序里面有大量的实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A(object):</span><br><span class="line">    pass</span><br><span class="line">a = A()</span><br><span class="line">a.addr = &quot;test&quot;</span><br><span class="line">a.name = &quot;test2&quot;</span><br><span class="line"></span><br><span class="line">print a.__dict__</span><br><span class="line">&#123;&apos;addr&apos;:&apos;test&apos;, &apos;name&apos;:&apos;test2&apos;&#125;</span><br></pre></td></tr></table></figure><p>当程序里面有大量的实例，就会存在大量字典</p><p>通过查看python源码，dict对象即pyDictObject对象 其本质是(hash table) + 开发定址法</p><p>因此，dict本质是一个稀疏数组，内存利用率很低 当大量实例就存在大量稀疏数组，导致内存浪费</p><h4 id="使用-slots-优化内存占用"><a href="#使用-slots-优化内存占用" class="headerlink" title="使用_slots_优化内存占用"></a>使用_slots_优化内存占用</h4><p>python中提供_slots_类属性，如果要处理数大量属性不多的实例时候，使用元组的格式存储实例，而不是字典</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class student(object):</span><br><span class="line">    __slots__ = (&apos;name&apos;, &apos;age&apos;)</span><br><span class="line">s = student()</span><br><span class="line">s.name = &quot;tom&quot;</span><br><span class="line">s.age = 15</span><br></pre></td></tr></table></figure><p>可以让解释器使用类似元组的格式存储实例属性，而不是字典</p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.a = &quot;string&quot;</span><br><span class="line">        self.b = 10</span><br><span class="line">        self.c = True</span><br><span class="line">class B(object):</span><br><span class="line">    __slots__ = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.a = &quot;string&quot;</span><br><span class="line">        self.b = 10</span><br><span class="line">        self.c = True</span><br></pre></td></tr></table></figure><p>测试：使用<strong>dict</strong>对比<strong>slots</strong>内存比为4：1</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>仅仅对当前类起作用，继承之类不起作用</li><li>实例只能拥有<em>slots</em>中列出的属性</li></ul><h3 id="set-or-list"><a href="#set-or-list" class="headerlink" title="set or list"></a>set or list</h3><p>大量 in 操作符，以及循环嵌套in，和在较多的集合中in</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>list：连续的数组 非链表<br>set : 类似dict hash结构</p><h4 id="查找速度"><a href="#查找速度" class="headerlink" title="查找速度"></a>查找速度</h4><p>hash肯定比 连续数组快</p><h2 id="python调用第三方程序"><a href="#python调用第三方程序" class="headerlink" title="python调用第三方程序"></a>python调用第三方程序</h2><p>对于一个可执行程序，经常被python调用</p><h3 id="subprocess源码"><a href="#subprocess源码" class="headerlink" title="subprocess源码"></a>subprocess源码</h3><p>可以看出这个原理是操作系统fork()进程，执行/bin/sh -c 来执行第三方命令</p><h3 id="用c封装py库来提高性能"><a href="#用c封装py库来提高性能" class="headerlink" title="用c封装py库来提高性能"></a>用c封装py库来提高性能</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static pyMethodDef GreateModuleMethods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;check&quot;,</span><br><span class="line">        _check,</span><br><span class="line">        METH_VARARGS,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;NULL, NULL,0,NULL&#125;</span><br><span class="line">&#125;</span><br><span class="line">PyMODINIT_FUNC initpng_check(void)&#123;</span><br><span class="line">    (void) Py_InitModule(&quot;png_check&quot;, GreateModuleMethods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python 代码import一次，加载到python进程的内存空间，得到调用接口，相比前面的方式性能高了很多<br>因此无需频繁fork()</p><h3 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h3><p>10w次，提升了4w多倍</p><h2 id="计算密集型场景的性能提升"><a href="#计算密集型场景的性能提升" class="headerlink" title="计算密集型场景的性能提升"></a>计算密集型场景的性能提升</h2><ul><li>Cpython</li><li>jython</li><li>pypy<ul><li>使用python实现的python解释器</li><li>集成了一种即时（JIT）编译器</li><li>当某方法或者代码块运行特别频繁是否，会将代码认定为热点代码，为了提高热点代码的执行效率，pypy会把这些代码变异为本地平台相关的机器码</li></ul></li></ul><h3 id="对比-2"><a href="#对比-2" class="headerlink" title="对比"></a>对比</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def add(x,y):</span><br><span class="line">    return x+y</span><br><span class="line">1000万次</span><br><span class="line">python test.py</span><br><span class="line">pypy test.py</span><br><span class="line"></span><br><span class="line">提升了104倍</span><br></pre></td></tr></table></figure><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>pypy与官方python并不兼容</li><li>不支持某些cpython的库 比如pandas</li><li>并不是运行所有程序都快</li></ul><h2 id="善用LINUX-API"><a href="#善用LINUX-API" class="headerlink" title="善用LINUX API"></a>善用LINUX API</h2><h3 id="读取大文件，修改文件的定点位置"><a href="#读取大文件，修改文件的定点位置" class="headerlink" title="读取大文件，修改文件的定点位置"></a>读取大文件，修改文件的定点位置</h3><ul><li>将文件全部读取到内存里面<ul><li>大量IO+内存占用</li></ul></li><li>找到定点,并且修改之后</li><li>将内存写到新文件里面<ul><li>大量IO操作</li></ul></li></ul><h4 id="使用linux自带的API"><a href="#使用linux自带的API" class="headerlink" title="使用linux自带的API"></a>使用linux自带的API</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f = open(big_file, &quot;rb+&quot;)</span><br><span class="line">f.seek(0, os.SEEK_END)</span><br><span class="line">file_size = f.tell()</span><br><span class="line">f.seek(0,0)</span><br><span class="line">f.truncate(file_size-32)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>使用linux自带的API来操作文件，直接根据当前文件偏移量来定位操作</p><p>seek调用仅将当前的文件偏移量记录在内核中，并不会带来IO操作</p><h3 id="获取网卡的IP"><a href="#获取网卡的IP" class="headerlink" title="获取网卡的IP"></a>获取网卡的IP</h3><ol><li>subprocess “ifconfig M”</li><li>利用python封装的LINUX提供的API</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">socket.inet_ntoa(fcntl.ioctl(s.fileno(), 0x8915, struct.pack(&quot;256s&quot;, ifname[:15])[20:24]))</span><br></pre></td></tr></table></figure><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>性能问题符合2/8法则。即20%代码引起了80%的性能损耗</p><p>可以用是用profile来定位瓶颈代码</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>python -m Cprofile test.py</p><p>ncalls 函数总的调用次数<br>ottime 函数内部（不包含子函数）的占用时间<br>percall (第一个) tottime/ncalls<br>cumtime 函数包含子函数所占用的时间<br>percall (第二个) cumtime/ncalls<br>filename:lineno(function) 文件：行号（函数）</p><h2 id="高性能容器collection"><a href="#高性能容器collection" class="headerlink" title="高性能容器collection"></a>高性能容器collection</h2><h3 id="deque-双向队列"><a href="#deque-双向队列" class="headerlink" title="deque 双向队列"></a>deque 双向队列</h3><p>通过源码知道deque保护了两个指针，指向上和下</p><p>比list对象insert快</p><h3 id="Counter-计数器"><a href="#Counter-计数器" class="headerlink" title="Counter 计数器"></a>Counter 计数器</h3><h3 id="OrderDict-有序字典"><a href="#OrderDict-有序字典" class="headerlink" title="OrderDict 有序字典"></a>OrderDict 有序字典</h3><h3 id="defaultdic-值带默认类型的字典"><a href="#defaultdic-值带默认类型的字典" class="headerlink" title="defaultdic 值带默认类型的字典"></a>defaultdic 值带默认类型的字典</h3><h3 id="namedtuple-可命名元组，通过名字来访问元组元素"><a href="#namedtuple-可命名元组，通过名字来访问元组元素" class="headerlink" title="namedtuple 可命名元组，通过名字来访问元组元素"></a>namedtuple 可命名元组，通过名字来访问元组元素</h3><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><ul><li>xrange 代替range  python3的range()默认为迭代器</li><li>使用join而不是+连接字符串</li><li>使用生成器表达式</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;python优化&quot;&gt;&lt;a href=&quot;#python优化&quot; class=&quot;headerlink&quot; title=&quot;python优化&quot;&gt;&lt;/a&gt;python优化&lt;/h1&gt;&lt;h2 id=&quot;处理文本-Unicode-三明治&quot;&gt;&lt;a href=&quot;#处理文本-Unicode-
      
    
    </summary>
    
      <category term="python" scheme="https://moonclearner.cn/categories/python/"/>
    
    
      <category term="python" scheme="https://moonclearner.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>ssl卸载</title>
    <link href="https://moonclearner.cn/ssl%E5%8D%B8%E8%BD%BD.html"/>
    <id>https://moonclearner.cn/ssl卸载.html</id>
    <published>2020-11-18T09:47:33.000Z</published>
    <updated>2020-11-19T06:42:39.271Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>WireSharkNote</title>
    <link href="https://moonclearner.cn/WireSharkNote.html"/>
    <id>https://moonclearner.cn/WireSharkNote.html</id>
    <published>2020-11-17T08:21:00.000Z</published>
    <updated>2020-11-18T11:09:29.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="wireshark-基础篇"><a href="#wireshark-基础篇" class="headerlink" title="wireshark 基础篇"></a>wireshark 基础篇</h1><h2 id="常见功能"><a href="#常见功能" class="headerlink" title="常见功能"></a>常见功能</h2><h2 id="显示过滤器"><a href="#显示过滤器" class="headerlink" title="显示过滤器"></a>显示过滤器</h2><h3 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h3><p>传输层：tcp udp sctp<br>数据链路层：Eter，lan，PPPOE<br>应-传输层：SSL<br>网-数据层：ARP</p><h3 id="协议字段"><a href="#协议字段" class="headerlink" title="协议字段"></a>协议字段</h3><h3 id="过滤关系"><a href="#过滤关系" class="headerlink" title="过滤关系"></a>过滤关系</h3><h3 id="常见的过滤"><a href="#常见的过滤" class="headerlink" title="常见的过滤"></a>常见的过滤</h3><ul><li>eth.src == 04:f9:38:11:11:11<ul><li>筛选源mac</li></ul></li><li>eth.type == 0x00<ul><li>筛选网络层使用ip协议的数据包</li></ul></li><li>ip.src != 192.168.1.1<ul><li>源ip不是</li><li>ip.addr</li><li>ip.dst</li></ul></li><li>http contains “test”<ul><li>查询http协议里面payload包含test字符串的包</li></ul></li><li>http.request.method</li></ul><h2 id="复合表达式过滤规则"><a href="#复合表达式过滤规则" class="headerlink" title="复合表达式过滤规则"></a>复合表达式过滤规则</h2><h3 id="连接词"><a href="#连接词" class="headerlink" title="连接词"></a>连接词</h3><ul><li>and , &amp;&amp;</li><li>or , ||</li><li>not , !</li><li>xor, ^^<ul><li>异或，相同出0 不同出1</li></ul></li><li>[…]<ul><li>分片</li></ul></li></ul><h3 id="常见复合式过滤器"><a href="#常见复合式过滤器" class="headerlink" title="常见复合式过滤器"></a>常见复合式过滤器</h3><ul><li>ip.src == 192.168.1.1 &amp;&amp; tcp[13]&amp;2<ul><li>筛选出源地址为192.168.1.1并且为syn的数据包</li></ul></li></ul><h2 id="捕获过滤器"><a href="#捕获过滤器" class="headerlink" title="捕获过滤器"></a>捕获过滤器</h2><p>ip src host 192.168.1.1</p><h3 id="捕获项"><a href="#捕获项" class="headerlink" title="捕获项"></a>捕获项</h3><h3 id="捕获参数"><a href="#捕获参数" class="headerlink" title="捕获参数"></a>捕获参数</h3><h3 id="捕获值"><a href="#捕获值" class="headerlink" title="捕获值"></a>捕获值</h3><h2 id="抓包简单分析"><a href="#抓包简单分析" class="headerlink" title="抓包简单分析"></a>抓包简单分析</h2><h3 id="快速查看整个包的协议框架"><a href="#快速查看整个包的协议框架" class="headerlink" title="快速查看整个包的协议框架"></a>快速查看整个包的协议框架</h3><ul><li>Frame -&gt;  protocols in frame: eth:ethertype:ip:tcp:http<ul><li>数据链路层 eth -&gt; ip协议  tcp协议 -&gt; http协议</li></ul></li><li>Ethernet <ul><li>type：IPv4<ul><li>告诉网络层用的什么协议</li></ul></li></ul></li><li>Internet Protocol<ul><li>Protocol:TCP<ul><li>告诉传输层使用什么协议</li></ul></li></ul></li><li>Transmission</li></ul><h3 id="如何查看更具体信息"><a href="#如何查看更具体信息" class="headerlink" title="如何查看更具体信息"></a>如何查看更具体信息</h3><p>右键追踪流</p><h1 id="https取证"><a href="#https取证" class="headerlink" title="https取证"></a>https取证</h1><h2 id="远程数据包捕获"><a href="#远程数据包捕获" class="headerlink" title="远程数据包捕获"></a>远程数据包捕获</h2><ul><li>远程windows系统需要安装winpcap,运行该程序，其对外端口默认为2002</li><li>本地有张网卡要与远程通信，添加一个远程网卡<ul><li>捕获》选项》管理接口》远程接口》加入远程设备端口为2002以及账号密码</li></ul></li></ul><h2 id="https解码"><a href="#https解码" class="headerlink" title="https解码"></a>https解码</h2><ul><li>使用捕获过滤器抓包</li><li>tlsv1包<ul><li>获取私钥，并且解压,获取pem文件<ul><li>openssl rsa -in server.key -out test.pem</li></ul></li></ul></li><li>选择要解密的流》编辑》首选项》protocols&gt;SSL&gt;RSA keys list&gt;Editors&gt;+&gt;<ul><li>wireshark 添加对应key用于解密，对应ip和端口 http协议以及key</li></ul></li><li>tlsv1包就会变成http包了</li></ul><h2 id="图片取证分析"><a href="#图片取证分析" class="headerlink" title="图片取证分析"></a>图片取证分析</h2><ul><li>抓包，找到流</li><li>右键追踪流-》http</li><li>显示和保存数据为 原始数据-》保存 保存为.bin文件</li><li>删除保留的文件的请求头</li><li>使用winhex 打开下载的bin文件，恢复成图片文件<h2 id="音频取证分析"><a href="#音频取证分析" class="headerlink" title="音频取证分析"></a>音频取证分析</h2></li></ul><h1 id="通信软件实时取证"><a href="#通信软件实时取证" class="headerlink" title="通信软件实时取证"></a>通信软件实时取证</h1><h2 id="包解密"><a href="#包解密" class="headerlink" title="包解密"></a>包解密</h2><p>wireshark自带解密工具</p><p>选择流&gt;解码为》</p><h3 id="qq解码"><a href="#qq解码" class="headerlink" title="qq解码"></a>qq解码</h3><p>UDP ， 8000 , OICQ</p><h3 id="找文件包"><a href="#找文件包" class="headerlink" title="找文件包"></a>找文件包</h3><p>过滤条件：data</p><h2 id="文件恢复"><a href="#文件恢复" class="headerlink" title="文件恢复"></a>文件恢复</h2><p>找到流-&gt;右键流追踪-&gt;保持为原始数据-&gt;保持为bin文件-&gt;winhex来恢复文件</p><p>http包可以删除请求头和返回头来恢复文件，但是tcp包整个没有头信息不用去删除</p><h3 id="winhex恢复文件"><a href="#winhex恢复文件" class="headerlink" title="winhex恢复文件"></a>winhex恢复文件</h3><p>加载bin文件之后&gt;File&gt;save as&gt;保持为对应的文件(可以从流里面查看文件格式)</p><h1 id="邮件取证"><a href="#邮件取证" class="headerlink" title="邮件取证"></a>邮件取证</h1><p>找到流：smtp</p><p>第一个334 下面是用户名<br>第二个 334 下面是密码<br>base64加密</p><h1 id="统计工具"><a href="#统计工具" class="headerlink" title="统计工具"></a>统计工具</h1><h2 id="部分文件统计"><a href="#部分文件统计" class="headerlink" title="部分文件统计"></a>部分文件统计</h2><p>用于统计当前网络有多少包，配合过滤器来知道当前网络什么包最多</p><p>统计》捕获文件属性</p><h2 id="协议分级统计"><a href="#协议分级统计" class="headerlink" title="协议分级统计"></a>协议分级统计</h2><p>根据tcp/ip模型来知道统计</p><p>统计》协议分级</p><h2 id="端点统计"><a href="#端点统计" class="headerlink" title="端点统计"></a>端点统计</h2><p>端到端的统计, 可以知道端口，以及包的大小</p><p>统计》endpoint</p><h2 id="对话统计"><a href="#对话统计" class="headerlink" title="对话统计"></a>对话统计</h2><p>类似端点统计多了持续时间</p><h2 id="http统计"><a href="#http统计" class="headerlink" title="http统计"></a>http统计</h2><ul><li>分组<ul><li>显示响应</li></ul></li><li>请求消息<ul><li>显示请求头的信息</li></ul></li><li>负载分配<ul><li>显示那些服务器回包</li></ul></li></ul><h2 id="tcp数据流"><a href="#tcp数据流" class="headerlink" title="tcp数据流"></a>tcp数据流</h2><p>统计》流量图</p><h2 id="IP属性"><a href="#IP属性" class="headerlink" title="IP属性"></a>IP属性</h2><p>统计》IPV4 统计</p><h1 id="信息统计"><a href="#信息统计" class="headerlink" title="信息统计"></a>信息统计</h1><h2 id="网络性能判定"><a href="#网络性能判定" class="headerlink" title="网络性能判定"></a>网络性能判定</h2><p>统计》IO图表</p><h2 id="链路吞吐量测算"><a href="#链路吞吐量测算" class="headerlink" title="链路吞吐量测算"></a>链路吞吐量测算</h2><h2 id="TCP吞吐量测算"><a href="#TCP吞吐量测算" class="headerlink" title="TCP吞吐量测算"></a>TCP吞吐量测算</h2><h2 id="TCP重传判断"><a href="#TCP重传判断" class="headerlink" title="TCP重传判断"></a>TCP重传判断</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;wireshark-基础篇&quot;&gt;&lt;a href=&quot;#wireshark-基础篇&quot; class=&quot;headerlink&quot; title=&quot;wireshark 基础篇&quot;&gt;&lt;/a&gt;wireshark 基础篇&lt;/h1&gt;&lt;h2 id=&quot;常见功能&quot;&gt;&lt;a href=&quot;#常见功能&quot;
      
    
    </summary>
    
      <category term="wireshark" scheme="https://moonclearner.cn/categories/wireshark/"/>
    
    
      <category term="wireshark" scheme="https://moonclearner.cn/tags/wireshark/"/>
    
  </entry>
  
  <entry>
    <title>kvm common command</title>
    <link href="https://moonclearner.cn/ubuntu/kvm.html"/>
    <id>https://moonclearner.cn/ubuntu/kvm.html</id>
    <published>2020-11-13T07:36:55.238Z</published>
    <updated>2020-11-13T07:36:55.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kvm-command"><a href="#kvm-command" class="headerlink" title="kvm command"></a>kvm command</h1><ul><li>virsh list –all<ul><li>gets the list of virtual machine info</li></ul></li><li>virsh start “Name”<ul><li>start virtual machine</li></ul></li><li>virsh shutdown “Id”<ul><li>shutdown virtual machine</li></ul></li><li>virsh console “Id”<ul><li>gets virtual machine console</li></ul></li><li>virsh dumpxml “Id” | grep file<ul><li>gets the image file path</li></ul></li><li>cat /etc/libvirt/qemu/<ul><li>get all virtual machine</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kvm-command&quot;&gt;&lt;a href=&quot;#kvm-command&quot; class=&quot;headerlink&quot; title=&quot;kvm command&quot;&gt;&lt;/a&gt;kvm command&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;virsh list –all&lt;ul&gt;
&lt;li&gt;gets
      
    
    </summary>
    
      <category term="kvm" scheme="https://moonclearner.cn/categories/kvm/"/>
    
    
      <category term="kvm" scheme="https://moonclearner.cn/tags/kvm/"/>
    
  </entry>
  
  <entry>
    <title>Mysql force function</title>
    <link href="https://moonclearner.cn/Mysql-force-function.html"/>
    <id>https://moonclearner.cn/Mysql-force-function.html</id>
    <published>2020-11-12T09:33:17.000Z</published>
    <updated>2020-11-13T02:02:25.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-强制函数"><a href="#Mysql-强制函数" class="headerlink" title="Mysql 强制函数"></a>Mysql 强制函数</h1><h2 id="强制索引-FORCE-INDEX"><a href="#强制索引-FORCE-INDEX" class="headerlink" title="强制索引  FORCE INDEX"></a>强制索引  FORCE INDEX</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM TABLE1 FORCE INDEX (FIELD1) …</span><br></pre></td></tr></table></figure><h2 id="忽略索引-IGNORE-INDEX"><a href="#忽略索引-IGNORE-INDEX" class="headerlink" title="忽略索引 IGNORE INDEX"></a>忽略索引 IGNORE INDEX</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM TABLE1 IGNORE INDEX (FIELD1, FIELD2) …</span><br></pre></td></tr></table></figure><h2 id="关闭查询缓冲-SQL-NO-CACHE"><a href="#关闭查询缓冲-SQL-NO-CACHE" class="headerlink" title="关闭查询缓冲 SQL_NO_CACHE"></a>关闭查询缓冲 SQL_NO_CACHE</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SQL_NO_CACHE field1, field2 FROM TABLE1;</span><br></pre></td></tr></table></figure><p>有一些SQL语句需要实时地查询数据，或者并不经常使用（可能一天就执行一两次）,这样就需要把缓冲关了,不管这条SQL语句是否被执行过，服务器都不会在缓冲区中查找，每次都会执行它。</p><h2 id="强制查询缓冲-SQL-CACHE"><a href="#强制查询缓冲-SQL-CACHE" class="headerlink" title="强制查询缓冲 SQL_CACHE"></a>强制查询缓冲 SQL_CACHE</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SQL_CALHE * FROM TABLE1;</span><br></pre></td></tr></table></figure><p>如果在my.ini中的query_cache_type设成2，这样只有在使用了SQL_CACHE后，才使用查询缓冲。</p><h2 id="优先操作-HIGH-PRIORITY"><a href="#优先操作-HIGH-PRIORITY" class="headerlink" title="优先操作 HIGH_PRIORITY"></a>优先操作 HIGH_PRIORITY</h2><p>HIGH_PRIORITY可以使用在select和insert操作中，让MySQL知道，这个操作优先进行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT HIGH_PRIORITY * FROM TABLE1;</span><br></pre></td></tr></table></figure><h2 id="滞后操作-LOW-PRIORITY"><a href="#滞后操作-LOW-PRIORITY" class="headerlink" title="滞后操作 LOW_PRIORITY"></a>滞后操作 LOW_PRIORITY</h2><p>LOW_PRIORITY可以使用在insert和update操作中，让MySQL知道，这个操作滞后。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update LOW_PRIORITY table1 set field1= where field1= …</span><br></pre></td></tr></table></figure><h2 id="延时插入-INSERT-DELAYED"><a href="#延时插入-INSERT-DELAYED" class="headerlink" title="延时插入 INSERT DELAYED"></a>延时插入 INSERT DELAYED</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT DELAYED INTO table1 set field1= …</span><br></pre></td></tr></table></figure><p>INSERT DELAYED INTO，是客户端提交数据给MySQL，MySQL返回OK状态给客户端。而这是并不是已经将数据插入表，而是存储在内存里面等待排队。当MySQL有 空余时，再插入。另一个重要的好处是，来自许多客户端的插入被集中在一起，并被编写入一个块。这比执行许多独立的插入要快很多。坏处是，不能返回自动递增 的ID，以及系统崩溃时，MySQL还没有来得及插入数据的话，这些数据将会丢失。</p><h2 id="强制连接顺序-STRAIGHT-JOIN"><a href="#强制连接顺序-STRAIGHT-JOIN" class="headerlink" title="强制连接顺序 STRAIGHT_JOIN"></a>强制连接顺序 STRAIGHT_JOIN</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT TABLE1.FIELD1, TABLE2.FIELD2 FROM TABLE1 STRAIGHT_JOIN TABLE2 WHERE …</span><br></pre></td></tr></table></figure><p>由上面的SQL语句可知，通过STRAIGHT_JOIN强迫MySQL按TABLE1、TABLE2的顺序连接表。如果你认为按自己的顺序比MySQL推荐的顺序进行连接的效率高的话，就可以通过STRAIGHT_JOIN来确定连接顺序</p><h2 id="强制使用临时表-SQL-BUFFER-RESULT"><a href="#强制使用临时表-SQL-BUFFER-RESULT" class="headerlink" title="强制使用临时表 SQL_BUFFER_RESULT"></a>强制使用临时表 SQL_BUFFER_RESULT</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SQL_BUFFER_RESULT * FROM TABLE1 WHERE …</span><br></pre></td></tr></table></figure><p>当我们查询的结果集中的数据比较多时，可以通过SQL_BUFFER_RESULT.选项强制将结果集放到临时表中，这样就可以很快地释放MySQL的表锁（这样其它的SQL语句就可以对这些记录进行查询了），并且可以长时间地为客户端提供大记录集</p><h2 id="分组使用临时表-SQL-BIG-RESULT和SQL-SMALL-RESULT"><a href="#分组使用临时表-SQL-BIG-RESULT和SQL-SMALL-RESULT" class="headerlink" title="分组使用临时表 SQL_BIG_RESULT和SQL_SMALL_RESULT"></a>分组使用临时表 SQL_BIG_RESULT和SQL_SMALL_RESULT</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SQL_BUFFER_RESULT FIELD1, COUNT(*) FROM TABLE1 GROUP BY FIELD1;</span><br></pre></td></tr></table></figure><p>一般用于分组或DISTINCT关键字，这个选项通知MySQL，如果有必要，就将查询结果放到临时表中，甚至在临时表中进行排序。SQL_SMALL_RESULT比起SQL_BIG_RESULT差不多，很少使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mysql-强制函数&quot;&gt;&lt;a href=&quot;#Mysql-强制函数&quot; class=&quot;headerlink&quot; title=&quot;Mysql 强制函数&quot;&gt;&lt;/a&gt;Mysql 强制函数&lt;/h1&gt;&lt;h2 id=&quot;强制索引-FORCE-INDEX&quot;&gt;&lt;a href=&quot;#强制索引-
      
    
    </summary>
    
      <category term="sql" scheme="https://moonclearner.cn/categories/sql/"/>
    
    
      <category term="sql" scheme="https://moonclearner.cn/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>sogou install</title>
    <link href="https://moonclearner.cn/ubuntu/sogou.html"/>
    <id>https://moonclearner.cn/ubuntu/sogou.html</id>
    <published>2020-11-11T06:08:43.076Z</published>
    <updated>2020-11-11T06:08:43.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ubuntu-20-04-install-sogou"><a href="#ubuntu-20-04-install-sogou" class="headerlink" title="ubuntu 20.04 install sogou"></a>ubuntu 20.04 install sogou</h1><p>ubuntu 20.04 不支持搜狗官方linux下载的deb</p><h2 id="使用ubuntukylin的-sogou输入法"><a href="#使用ubuntukylin的-sogou输入法" class="headerlink" title="使用ubuntukylin的 sogou输入法"></a>使用ubuntukylin的 sogou输入法</h2><h3 id="添加ubuntukylin源"><a href="#添加ubuntukylin源" class="headerlink" title="添加ubuntukylin源"></a>添加ubuntukylin源</h3><p>根据官方教程添加ukui的官方源，为了安装及后续更新。此源中包含了麒麟版搜狗输入法。</p><p>$ curl -sL ‘<a href="https://keyserver.ubuntu.com/pks/lookup?&amp;op=get&amp;search=0x73BC8FBCF5DE40C6ADFCFFFA9C949F2093F565FF&#39;" target="_blank" rel="noopener">https://keyserver.ubuntu.com/pks/lookup?&amp;op=get&amp;search=0x73BC8FBCF5DE40C6ADFCFFFA9C949F2093F565FF&#39;</a> | sudo apt-key add<br>$ sudo apt-add-repository ‘deb <a href="http://archive.ubuntukylin.com/ukui" target="_blank" rel="noopener">http://archive.ubuntukylin.com/ukui</a> focal main’<br>$ sudo apt upgrade</p><h3 id="安装搜狗输入法"><a href="#安装搜狗输入法" class="headerlink" title="安装搜狗输入法"></a>安装搜狗输入法</h3><p>直接安装软件包，注意包名是sogouimebs而不是原来的sogoupinyin。这个版本在其他地方暂时是找不到的，因为是麒麟社区定制的版本。由于ubuntu和优麒麟一脉相承的关系，我们可以直接拿来用。</p><p>$ sudo apt install sogouimebs</p><h3 id="输入法设置"><a href="#输入法设置" class="headerlink" title="输入法设置"></a>输入法设置</h3><p>根据自身需求针对输入法属性进行设置</p><p>$ sogouIme-configtool </p><h3 id="shift-ctrl-就可以切换语言"><a href="#shift-ctrl-就可以切换语言" class="headerlink" title="shift + ctrl 就可以切换语言"></a>shift + ctrl 就可以切换语言</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ubuntu-20-04-install-sogou&quot;&gt;&lt;a href=&quot;#ubuntu-20-04-install-sogou&quot; class=&quot;headerlink&quot; title=&quot;ubuntu 20.04 install sogou&quot;&gt;&lt;/a&gt;ubuntu 2
      
    
    </summary>
    
      <category term="compile" scheme="https://moonclearner.cn/categories/compile/"/>
    
    
      <category term="ubuntu" scheme="https://moonclearner.cn/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>索引覆盖与回表</title>
    <link href="https://moonclearner.cn/%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E4%B8%8E%E5%9B%9E%E8%A1%A8.html"/>
    <id>https://moonclearner.cn/索引覆盖与回表.html</id>
    <published>2020-11-11T02:36:11.000Z</published>
    <updated>2020-11-12T08:59:43.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql的覆盖索引与回表"><a href="#Mysql的覆盖索引与回表" class="headerlink" title="Mysql的覆盖索引与回表"></a>Mysql的覆盖索引与回表</h1><p>##两大类索引<br>使用的存储引擎：MySQL5.7 InnoDB</p><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><ul><li>如果表设置了主键，则主键就是聚簇索引</li><li>如果表没有主键，则会默认第一个NOT NULL，且唯一（UNIQUE）的列作为聚簇索引</li><li>以上都没有，则会默认创建一个隐藏的row_id作为聚簇索引<br>InnoDB的聚簇索引的叶子节点存储的是行记录（其实是页结构，一个页包含多行数据），InnoDB必须要有至少一个聚簇索引。<br>由此可见，使用聚簇索引查询会很快，因为可以直接定位到行记录。<h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3>普通索引也叫二级索引，除聚簇索引外的索引，即非聚簇索引。<br>InnoDB的普通索引叶子节点存储的是主键（聚簇索引）的值，而MyISAM的普通索引存储的是记录指针。<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table user(</span><br><span class="line">    -&gt; id int(10) auto_increment,</span><br><span class="line">    -&gt; name varchar(30),</span><br><span class="line">    -&gt; age tinyint(4),</span><br><span class="line">    -&gt; primary key (id),</span><br><span class="line">    -&gt; index idx_age (age)</span><br><span class="line">    -&gt; )engine=innodb charset=utf8mb4;</span><br></pre></td></tr></table></figure></li></ul><p>id 字段是聚簇索引，age 字段是普通索引（二级索引）</p><h3 id="填充数据"><a href="#填充数据" class="headerlink" title="填充数据"></a>填充数据</h3><ul><li>insert into user(name,age) values(‘张三’,30);</li><li>insert into user(name,age) values(‘李四’,20);</li><li>insert into user(name,age) values(‘王五’,40);</li><li>insert into user(name,age) values(‘刘八’,10);</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+--------+------+</span><br><span class="line">| id | name  | age |</span><br><span class="line">+----+--------+------+</span><br><span class="line">| 1 | 张三  |  30 |</span><br><span class="line">| 2 | 李四  |  20 |</span><br><span class="line">| 3 | 王五  |  40 |</span><br><span class="line">| 4 | 刘八  |  10 |</span><br><span class="line">+----+--------+------+</span><br></pre></td></tr></table></figure><h3 id="索引存储结构"><a href="#索引存储结构" class="headerlink" title="索引存储结构"></a>索引存储结构</h3><p>id 是主键，所以是聚簇索引，其叶子节点存储的是对应行记录的数据</p><img src="/索引覆盖与回表/20201111-105447.png"><h4 id="聚簇索引（ClusteredIndex）"><a href="#聚簇索引（ClusteredIndex）" class="headerlink" title="聚簇索引（ClusteredIndex）"></a>聚簇索引（ClusteredIndex）</h4><p>age 是普通索引（二级索引），非聚簇索引，其叶子节点存储的是聚簇索引的的值</p><img src="/索引覆盖与回表/20201111-105757.png"><h4 id="普通索引（secondaryIndex）"><a href="#普通索引（secondaryIndex）" class="headerlink" title="普通索引（secondaryIndex）"></a>普通索引（secondaryIndex）</h4><p>如果查询条件为主键（聚簇索引），则只需扫描一次B+树即可通过聚簇索引定位到要查找的行记录数据。<br>如：select * from user where id = 1;</p><img src="/索引覆盖与回表/20201111-105824.png"><h4 id="聚簇索引查找过程"><a href="#聚簇索引查找过程" class="headerlink" title="聚簇索引查找过程"></a>聚簇索引查找过程</h4><p>如果查询条件为普通索引（非聚簇索引），需要扫描两次B+树，第一次扫描通过普通索引定位到聚簇索引的值，然后第二次扫描通过聚簇索引的值定位到要查找的行记录数据。 如：select * from user where age = 30;</p><ol><li>先通过普通索引 age=30 定位到主键值 id=1</li><li>再通过聚集索引 id=1 定位到行记录数据<img src="/索引覆盖与回表/20201111-105840.png"></li></ol><p>普通索引查找过程第一步</p><img src="/索引覆盖与回表/20201111-105845.png"><p>普通索引查找过程第二步</p><h3 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询"></a>回表查询</h3><p>先通过普通索引的值定位聚簇索引值，再通过聚簇索引的值定位行记录数据，需要扫描两次索引B+树，它的性能较扫一遍索引树更低。</p><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。</p><p>例如：select id,age from user where age = 10;</p><h3 id="如何实现覆盖索引"><a href="#如何实现覆盖索引" class="headerlink" title="如何实现覆盖索引"></a>如何实现覆盖索引</h3><p>常见的方法是：将被查询的字段，建立到联合索引里去。</p><p>1、如实现：select id,age from user where age = 10;</p><p>explain分析：因为age是普通索引，使用到了age索引，通过一次扫描B+树即可查询到相应的结果，这样就实现了覆盖索引</p><img src="/索引覆盖与回表/20201111-105903.png"><p>2、实现：select id,age,name from user where age = 10;</p><p>explain分析：age是普通索引，但name列不在索引树上，所以通过age索引在查询到id和age的值后，需要进行回表再查询name的值。此时的Extra列的NULL表示进行了回表查询</p><img src="/索引覆盖与回表/20201111-105908.png"><p>为了实现索引覆盖，需要建组合索引idx_age_name(age,name)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drop index idx_age on user;</span><br><span class="line">create index idx_age_name on user(`age`,`name`);</span><br></pre></td></tr></table></figure></p><p>explain分析：此时字段age和name是组合索引idx_age_name，查询的字段id、age、name的值刚刚都在索引树上，只需扫描一次组合索引B+树即可，这就是实现了索引覆盖，此时的Extra字段为Using index表示使用了索引覆盖。</p><img src="/索引覆盖与回表/20201111-105916.png"><p>哪些场景适合使用索引覆盖来优化SQL</p><p>全表count查询优化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table user(</span><br><span class="line">    -&gt; id int(10) auto_increment,</span><br><span class="line">    -&gt; name varchar(30),</span><br><span class="line">    -&gt; age tinyint(4),</span><br><span class="line">    -&gt; primary key (id),</span><br><span class="line">    -&gt; )engine=innodb charset=utf8mb4;</span><br></pre></td></tr></table></figure></p><p>例如：select count(age) from user;</p><img src="/索引覆盖与回表/20201111-105959.png"><p>使用索引覆盖优化：创建age字段索引</p><p>create index idx_age on user(age);</p><img src="/索引覆盖与回表/20201111-110004.png"><h3 id="列查询回表优化"><a href="#列查询回表优化" class="headerlink" title="列查询回表优化"></a>列查询回表优化</h3><p>前文在描述索引覆盖使用的例子就是</p><p>例如：select id,age,name from user where age = 10;</p><p>使用索引覆盖：建组合索引idx_age_name(age,name)即可</p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>例如：select id,age,name from user order by age limit 100,2;<br>因为name字段不是索引，所以在分页查询需要进行回表查询，此时Extra为Using filesort文件排序，查询性能低下。</p><img src="/索引覆盖与回表/20201111-110100.png"><p>使用索引覆盖：建组合索引idx_age_name(age,name)</p><img src="/索引覆盖与回表/20201111-110105.png"><p>引用作者 <a href="https://zhuanlan.zhihu.com/p/107125866" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/107125866</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mysql的覆盖索引与回表&quot;&gt;&lt;a href=&quot;#Mysql的覆盖索引与回表&quot; class=&quot;headerlink&quot; title=&quot;Mysql的覆盖索引与回表&quot;&gt;&lt;/a&gt;Mysql的覆盖索引与回表&lt;/h1&gt;&lt;p&gt;##两大类索引&lt;br&gt;使用的存储引擎：MySQL5.
      
    
    </summary>
    
      <category term="sql" scheme="https://moonclearner.cn/categories/sql/"/>
    
    
      <category term="sql" scheme="https://moonclearner.cn/tags/sql/"/>
    
  </entry>
  
</feed>
